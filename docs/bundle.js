/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./images/book.png":
/*!*************************!*\
  !*** ./images/book.png ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"images/book.png\";\n\n//# sourceURL=webpack://projectjs/./images/book.png?");

/***/ }),

/***/ "./images/character_blue.png":
/*!***********************************!*\
  !*** ./images/character_blue.png ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"images/character_blue.png\";\n\n//# sourceURL=webpack://projectjs/./images/character_blue.png?");

/***/ }),

/***/ "./images/character_green.png":
/*!************************************!*\
  !*** ./images/character_green.png ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"images/character_green.png\";\n\n//# sourceURL=webpack://projectjs/./images/character_green.png?");

/***/ }),

/***/ "./images/character_red.png":
/*!**********************************!*\
  !*** ./images/character_red.png ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"images/character_red.png\";\n\n//# sourceURL=webpack://projectjs/./images/character_red.png?");

/***/ }),

/***/ "./images/character_yellow.png":
/*!*************************************!*\
  !*** ./images/character_yellow.png ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"images/character_yellow.png\";\n\n//# sourceURL=webpack://projectjs/./images/character_yellow.png?");

/***/ }),

/***/ "./js/Core/Character.js":
/*!******************************!*\
  !*** ./js/Core/Character.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Character: () => (/* binding */ Character)\n/* harmony export */ });\n// src/core/Character.js\r\n\r\nclass Character {\r\n  /** Static object for direction constants */\r\n  static Direction = {\r\n    DOWN: 0,\r\n    RIGHT: 1,\r\n    UP: 2,\r\n    LEFT: 3,\r\n  };\r\n\r\n  /**\r\n   * Creates a new Character instance.\r\n   * @param {CanvasRenderingContext2D} ctx - The rendering context.\r\n   * @param {string} spriteUrl - URL of the character's sprite sheet.\r\n   * @param {object} options - Configuration options.\r\n   * @param {number} [options.frameSize=32] - Size of one frame in the sprite sheet (pixels).\r\n   * @param {number} [options.frameCount=4] - Number of frames per animation cycle (per direction).\r\n   * @param {number} [options.scale=2] - Scaling factor for rendering.\r\n   * @param {number} [options.speed=3] - Movement speed in pixels per update.\r\n   * @param {number} [options.animationSpeed=150] - Milliseconds per animation frame.\r\n   * @param {number} [options.collisionBoxWidthRatio=0.4] - Width of collision box relative to renderSize.\r\n   * @param {number} [options.collisionBoxHeightRatio=0.2] - Height of collision box relative to renderSize.\r\n   * @param {number} [options.collisionBoxFeetOffsetRatio=0.4] - Vertical offset of collision box center from character center (towards feet), relative to renderSize.\r\n   */\r\n  constructor(ctx, spriteUrl, options = {}) {\r\n    this.ctx = ctx;\r\n    this.sprite = new Image();\r\n\r\n    // Configuration with defaults\r\n    this.frameSize = options.frameSize || 32;\r\n    this.frameCount = options.frameCount || 4; // Number of frames per direction\r\n    this.scale = options.scale || 2;\r\n    this.renderSize = this.frameSize * this.scale;\r\n    this.speed = options.speed || 3;\r\n    this.animationSpeed = options.animationSpeed || 150; // ms per frame\r\n\r\n    // Collision Box Configuration\r\n    this.collisionBoxWidthRatio = options.collisionBoxWidthRatio || 0.4;\r\n    this.collisionBoxHeightRatio = options.collisionBoxHeightRatio || 0.2;\r\n    this.collisionBoxFeetOffsetRatio = options.collisionBoxFeetOffsetRatio || 0.4;\r\n\r\n    // State\r\n    this.x = 0; // World X coordinate\r\n    this.y = 0; // World Y coordinate\r\n    this.currentDirection = Character.Direction.DOWN; // Start facing down\r\n    this.currentFrame = 0; // Current animation frame index\r\n    this.isMoving = false; // Is the character currently moving?\r\n    this.lastFrameTime = 0; // Timestamp of the last frame update\r\n\r\n    // Load sprite and add handlers\r\n    this.sprite.onload = () => {\r\n      console.log(`[Character] Sprite loaded successfully: ${spriteUrl}`);\r\n    };\r\n    this.sprite.onerror = () => {\r\n      console.error(`[Character] Failed to load sprite: ${spriteUrl}`);\r\n    };\r\n    this.sprite.src = spriteUrl; // Start loading\r\n  }\r\n\r\n  /**\r\n   * Updates the character's animation frame based on movement state and time.\r\n   * Should be called in the game's update loop.\r\n   * @param {number} timestamp - The current high-resolution timestamp (e.g., from requestAnimationFrame).\r\n   */\r\n  updateAnimation(timestamp) {\r\n    if (!this.isMoving) {\r\n      this.currentFrame = 0;\r\n      this.lastFrameTime = timestamp;\r\n      return;\r\n    }\r\n    if (!this.lastFrameTime) {\r\n      this.lastFrameTime = timestamp;\r\n    }\r\n    const elapsed = timestamp - this.lastFrameTime;\r\n    if (elapsed > this.animationSpeed) {\r\n      this.currentFrame = (this.currentFrame + 1) % this.frameCount;\r\n      this.lastFrameTime = timestamp;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates the collision bounding box based on a potential position.\r\n   * @param {number} posX - The potential X coordinate for the collision check.\r\n   * @param {number} posY - The potential Y coordinate for the collision check.\r\n   * @returns {{top: number, bottom: number, left: number, right: number, width: number, height: number}} The collision box properties.\r\n   */\r\n  getCollisionBox(posX, posY) {\r\n    const width = this.renderSize * this.collisionBoxWidthRatio;\r\n    const height = this.renderSize * this.collisionBoxHeightRatio;\r\n    const halfWidth = width / 2;\r\n    const feetOffsetY = this.renderSize * this.collisionBoxFeetOffsetRatio;\r\n    const top = posY + feetOffsetY - height / 2;\r\n    const bottom = posY + feetOffsetY + height / 2;\r\n    const left = posX - halfWidth;\r\n    const right = posX + halfWidth;\r\n    return { top, bottom, left, right, width, height };\r\n  }\r\n\r\n  /**\r\n   * Draws the character onto the canvas at its current position,\r\n   * considering the camera offset.\r\n   * @param {number} offsetX - The camera's X offset.\r\n   * @param {number} offsetY - The camera's Y offset.\r\n   */\r\n  draw(offsetX, offsetY) {\r\n    if (!this.sprite.complete || this.sprite.naturalHeight === 0) {\r\n      return; // Don't draw if sprite isn't ready\r\n    }\r\n    const frameX = this.currentFrame * this.frameSize;\r\n    const frameY = this.currentDirection * this.frameSize;\r\n    const screenX = Math.floor(this.x - this.renderSize / 2 + offsetX);\r\n    const screenY = Math.floor(this.y - this.renderSize / 2 + offsetY);\r\n\r\n    try {\r\n      this.ctx.drawImage(\r\n        this.sprite,\r\n        frameX,\r\n        frameY,\r\n        this.frameSize,\r\n        this.frameSize, // Source rect\r\n        screenX,\r\n        screenY,\r\n        this.renderSize,\r\n        this.renderSize // Dest rect\r\n      );\r\n    } catch (e) {\r\n      console.error('[Character] Error drawing sprite:', e);\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://projectjs/./js/Core/Character.js?");

/***/ }),

/***/ "./js/Core/Game.js":
/*!*************************!*\
  !*** ./js/Core/Game.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _InputManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InputManager.js */ \"./js/Core/InputManager.js\");\n/* harmony import */ var _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/UIManager.js */ \"./js/UI/UIManager.js\");\n/* harmony import */ var _Character_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Character.js */ \"./js/Core/Character.js\");\n/* harmony import */ var _Level_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Level.js */ \"./js/Core/Level.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/constants.js */ \"./js/utils/constants.js\");\n/* harmony import */ var _GameRenderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GameRenderer.js */ \"./js/Core/GameRenderer.js\");\n/* harmony import */ var _GameplayManager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GameplayManager.js */ \"./js/Core/GameplayManager.js\");\n/* harmony import */ var _images_character_red_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../images/character_red.png */ \"./images/character_red.png\");\n/* harmony import */ var _images_character_blue_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../images/character_blue.png */ \"./images/character_blue.png\");\n/* harmony import */ var _images_character_yellow_png__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../images/character_yellow.png */ \"./images/character_yellow.png\");\n/* harmony import */ var _images_character_green_png__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../images/character_green.png */ \"./images/character_green.png\");\n/* harmony import */ var _images_book_png__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../images/book.png */ \"./images/book.png\");\n// src/core/Game.js\r\n\r\n// Używamy poprawnej wielkości liter w nazwie folderu/pliku: UI/UIManager.js\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Importy zasobów (assets) (ścieżki muszą być poprawne względem pliku HTML)\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Game {\r\n  constructor(characterColor) {\r\n    console.log(`[Game] Inicjalizacja z postacią: ${characterColor}`);\r\n    this.characterColor = characterColor;\r\n    this._gameState = _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.LOADING;\r\n    this.isRunning = false;\r\n\r\n    // Globalne zmienne gry\r\n    this.totalBooksCollectedGlobally = 0;\r\n    this.targetBooksToWin = _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TARGET_BOOKS_TO_WIN;\r\n    this.availableQuestions = [];\r\n\r\n    // Stan interakcji\r\n    this.currentBookTarget = null;\r\n    this.currentQuestionData = null;\r\n    this.liftCooldownActive = false;\r\n    this.liftCooldownTimer = null;\r\n\r\n    // Główne komponenty gry\r\n    this.canvas = null;\r\n    this.ctx = null;\r\n    this.character = null;\r\n    this.level = null;\r\n    this.inputManager = null;\r\n    this.renderer = null;\r\n    this.gameplayManager = null; // Inicjalizowany później\r\n\r\n    // Załadowane zasoby (assets)\r\n    this.sprites = { red: _images_character_red_png__WEBPACK_IMPORTED_MODULE_7__, blue: _images_character_blue_png__WEBPACK_IMPORTED_MODULE_8__, yellow: _images_character_yellow_png__WEBPACK_IMPORTED_MODULE_9__, green: _images_character_green_png__WEBPACK_IMPORTED_MODULE_10__ };\r\n    this.bookImage = null;\r\n\r\n    // Powiązanie metod z kontekstem\r\n    this.gameLoop = this.gameLoop.bind(this);\r\n    this._handleFatalError = this._handleFatalError.bind(this);\r\n\r\n    // --- Sekwencja inicjalizacji ---\r\n    try {\r\n      this._initializeCoreComponents(); // Synchroniczna inicjalizacja podstawowych menedżerów\r\n      this.renderer = new _GameRenderer_js__WEBPACK_IMPORTED_MODULE_5__.GameRenderer(this); // Inicjalizacja renderera\r\n      const { canvas, ctx } = this.renderer.initializeCanvas(); // Pobranie canvas i context\r\n      this.canvas = canvas;\r\n      this.ctx = ctx;\r\n      this.gameplayManager = new _GameplayManager_js__WEBPACK_IMPORTED_MODULE_6__.GameplayManager(this); // Inicjalizacja menedżera rozgrywki (GameplayManager)\r\n      this._addEventListeners(); // Dodanie globalnych nasłuchiwaczy (resize)\r\n      this._loadAssetsAndStart(); // Asynchroniczne ładowanie zasobów i start gry\r\n    } catch (error) {\r\n      console.error('[Game] Inicjalizacja rdzenia nie powiodła się:', error);\r\n      // Pokazujemy alert, ponieważ UI może jeszcze nie być gotowe\r\n      alert(`Krytyczny błąd inicjalizacji: ${error.message}`);\r\n      // Ustawiamy stan błędu bez alertu (już został wyświetlony)\r\n      this._handleFatalError(`Błąd inicjalizacji: ${error.message}`, false);\r\n    }\r\n  }\r\n\r\n  // --- Getter/Setter dla stanu gry ---\r\n  get gameState() {\r\n    return this._gameState;\r\n  }\r\n  setGameState(newState) {\r\n    if (this._gameState !== newState) {\r\n      console.log(`[Stan Gry] ${this._gameState} -> ${newState}`);\r\n      this._gameState = newState;\r\n    }\r\n  }\r\n\r\n  // Inicjalizacja podstawowych menedżerów\r\n  _initializeCoreComponents() {\r\n    this.inputManager = new _InputManager_js__WEBPACK_IMPORTED_MODULE_0__.InputManager();\r\n    this.level = new _Level_js__WEBPACK_IMPORTED_MODULE_3__.Level(1, 3); // Piętra od 1 do 3\r\n  }\r\n\r\n  // Dodawanie nasłuchiwaczy zdarzeń okna\r\n  _addEventListeners() {\r\n    // Zmiana rozmiaru canvas jest obsługiwana przez renderer\r\n    window.addEventListener('resize', () => this.renderer?.resizeCanvas());\r\n    // Nasłuchiwacze klawiatury są dodawane w startGame\r\n  }\r\n\r\n  // Asynchroniczne ładowanie zasobów i uruchomienie gry\r\n  async _loadAssetsAndStart() {\r\n    try {\r\n      this.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.LOADING); // Ustawiamy stan ładowania\r\n      await this._loadAssets(); // Oczekujemy na załadowanie wszystkich zasobów\r\n      this._initializeUI(); // Inicjalizujemy UI po załadowaniu (jeśli potrzebne)\r\n      await this.startGame(); // Uruchamiamy główną logikę gry\r\n    } catch (error) {\r\n      console.error(\r\n        '[Game] Ładowanie zasobów / inicjalizacja UI / start gry nie powiodły się:',\r\n        error\r\n      );\r\n      this._handleFatalError(`Błąd ładowania zasobów lub startu gry: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Ładowanie obrazów (sprite'y, książka)\r\n  async _loadAssets() {\r\n    console.log('[Game] Ładowanie zasobów...');\r\n    const promises = [];\r\n    const spritePath = this.sprites[this.characterColor] || this.sprites.red; // Wybór sprite'a\r\n\r\n    // Tworzenie postaci (wymaga ctx)\r\n    if (!this.ctx) throw new Error('Kontekst Canvas niedostępny do utworzenia Postaci.');\r\n    this.character = new _Character_js__WEBPACK_IMPORTED_MODULE_2__.Character(this.ctx, spritePath, {\r\n      speed: 3,\r\n      frameSize: 32,\r\n      scale: 2,\r\n      animationSpeed: 150,\r\n      frameCount: 4,\r\n    });\r\n    // Promise do załadowania sprite'a postaci\r\n    promises.push(\r\n      new Promise((resolve, reject) => {\r\n        // Pomyślne załadowanie\r\n        this.character.sprite.onload = () => {\r\n          console.log(`  [Zasoby] Sprite postaci załadowany: ${spritePath}`);\r\n          resolve();\r\n        };\r\n        // Błąd ładowania\r\n        this.character.sprite.onerror = (err) =>\r\n          reject(new Error(`Nie udało się załadować sprite'a postaci: ${spritePath}. ${err}`));\r\n      })\r\n    );\r\n\r\n    // Ładowanie obrazu książki\r\n    if (_images_book_png__WEBPACK_IMPORTED_MODULE_11__) {\r\n      this.bookImage = new Image();\r\n      this.bookImage.src = _images_book_png__WEBPACK_IMPORTED_MODULE_11__;\r\n      // Promise do załadowania książki\r\n      promises.push(\r\n        new Promise((resolve, reject) => {\r\n          // Pomyślne załadowanie\r\n          this.bookImage.onload = () => {\r\n            console.log(`  [Zasoby] Obraz książki załadowany: ${_images_book_png__WEBPACK_IMPORTED_MODULE_11__}`);\r\n            resolve();\r\n          };\r\n          // Błąd ładowania (niekrytyczny, istnieje renderowanie zapasowe - fallback)\r\n          this.bookImage.onerror = () => {\r\n            console.warn(\r\n              ` [Zasoby] Nie udało się załadować obrazu książki: ${_images_book_png__WEBPACK_IMPORTED_MODULE_11__}. Używanie renderowania zapasowego (fallback).`\r\n            );\r\n            this.bookImage = null; // Resetujemy, aby użyć fallback\r\n            resolve(); // Mimo wszystko rozwiązujemy (resolve) promise\r\n          };\r\n        })\r\n      );\r\n    } else {\r\n      console.warn(\r\n        \"[Zasoby] Brak ścieżki do sprite'a książki. Używanie renderowania zapasowego (fallback).\"\r\n      );\r\n      this.bookImage = null;\r\n    }\r\n\r\n    // Oczekujemy na zakończenie wszystkich promisów ładowania\r\n    await Promise.all(promises);\r\n    console.log('[Game] Zasoby załadowane pomyślnie.');\r\n  }\r\n\r\n  // Inicjalizacja elementów UI przez UIManager\r\n  _initializeUI() {\r\n    console.log('[Game] Inicjalizacja Menedżera UI...');\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.createControls(this.inputManager); // Tworzenie przycisków sterowania\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.createQuestionUI(); // Tworzenie UI dla pytań\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.createFloorSelectionUI(); // Tworzenie UI do wyboru piętra\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.ensureFlashMessageContainer(); // Upewniamy się, że kontener wiadomości istnieje\r\n    // ! Kluczowy moment: przekazujemy instancję GameplayManager do UIManager !\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.setGameplayManager(this.gameplayManager);\r\n    console.log('[Game] Konfiguracja Menedżera UI zakończona.');\r\n  }\r\n\r\n  // Główna funkcja startu lub restartu gry\r\n  async startGame() {\r\n    console.log('[Game] Rozpoczynanie gry...');\r\n    // Sprawdzenie obecności wszystkich niezbędnych komponentów\r\n    if (!this.level || !this.character || !this.canvas || !this.renderer || !this.gameplayManager) {\r\n      throw new Error('Nie można rozpocząć gry - brak niezbędnych komponentów.');\r\n    }\r\n\r\n    this.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.LOADING); // Stan ładowania poziomu\r\n    // Ukrywamy cały interfejs użytkownika przed startem\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideGameUI();\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideQuestion();\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideFloorSelectionUI();\r\n\r\n    try {\r\n      // 1. Ładujemy początkowe piętro (asynchronicznie)\r\n      await this.level.loadFloor(this.level.minFloor, this.canvas.width, this.canvas.height);\r\n      const currentMap = this.level.currentMap;\r\n      if (!currentMap) {\r\n        throw new Error('Nie udało się załadować początkowej mapy. Obiekt mapy jest null.');\r\n      }\r\n\r\n      // 2. Znajdujemy pozycję startową na mapie\r\n      const startPos = currentMap.findRandomInitialSpawnPosition();\r\n      if (!startPos) {\r\n        throw new Error('Nie udało się znaleźć prawidłowej pozycji startowej na mapie!');\r\n      }\r\n\r\n      // 3. Ustawiamy początkowe współrzędne i stan postaci\r\n      this.character.x = startPos.x;\r\n      this.character.y = startPos.y;\r\n      this.character.currentDirection = _Character_js__WEBPACK_IMPORTED_MODULE_2__.Character.Direction.DOWN;\r\n      this.character.isMoving = false;\r\n\r\n      // 4. ! WAŻNE: Sprawdzamy, czy postać nie zespawnowała się od razu w ścianie !\r\n      // Przekazujemy false (lub nie przekazujemy), ponieważ początkowy spawn nie powinien być na windzie\r\n      this.gameplayManager?.ensureCharacterIsOnWalkableTile(false);\r\n\r\n      // 5. Resetowanie zmiennych gry\r\n      this.totalBooksCollectedGlobally = 0;\r\n      this.availableQuestions = [..._utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.questions]; // Nowy zestaw pytań\r\n      this.liftCooldownActive = false;\r\n      clearTimeout(this.liftCooldownTimer); // Resetowanie timera cooldownu\r\n      this.liftCooldownTimer = null;\r\n      this.currentBookTarget = null;\r\n      this.currentQuestionData = null;\r\n\r\n      // 6. Centrujemy kamerę PO ustawieniu pozycji i ewentualnym wypchnięciu\r\n      this.renderer.centerCameraOnCharacter();\r\n\r\n      // 7. Aktualizujemy i pokazujemy interfejs gry\r\n      _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.updateScore(this.totalBooksCollectedGlobally, this.targetBooksToWin);\r\n      _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.showGameUI(); // Pokazujemy canvas, wynik, kontrolki\r\n\r\n      // 8. Dodajemy nasłuchiwacze klawiatury\r\n      // Powiązujemy 'this', aby wewnątrz handlerów był dostęp do instancji Game\r\n      this._boundKeyDownHandler = this.handleKeyDown.bind(this);\r\n      this._boundKeyUpHandler = this.handleKeyUp.bind(this);\r\n      window.addEventListener('keydown', this._boundKeyDownHandler);\r\n      window.addEventListener('keyup', this._boundKeyUpHandler);\r\n\r\n      // 9. Przełączamy grę w stan aktywny i uruchamiamy pętlę gry\r\n      this.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.PLAYING);\r\n      if (!this.isRunning) {\r\n        this.isRunning = true;\r\n        requestAnimationFrame(this.gameLoop); // Uruchomienie pętli\r\n        console.log('[Game] Gra rozpoczęta pomyślnie. Pętla działa.');\r\n      }\r\n    } catch (error) {\r\n      // Obsługa błędów podczas startu (ładowanie mapy, szukanie spawnu)\r\n      console.error('[Game] Błąd podczas procesu startGame:', error);\r\n      this._handleFatalError(`Błąd startu poziomu: ${error.message}`);\r\n      this.isRunning = false; // Upewniamy się, że pętla się nie uruchomi\r\n    }\r\n  }\r\n\r\n  // Zakończenie gry (wygrana lub błąd)\r\n  _setGameOver(win = true) {\r\n    if (this.gameState === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.GAME_OVER) return; // Nie kończymy gry dwukrotnie\r\n\r\n    this.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.GAME_OVER);\r\n    this.isRunning = false; // Zatrzymujemy pętlę gry\r\n    if (this.character) this.character.isMoving = false; // Zatrzymujemy animację postaci\r\n    clearTimeout(this.liftCooldownTimer); // Zatrzymujemy timer windy\r\n\r\n    // Usuwamy nasłuchiwacze klawiatury dodane w startGame\r\n    if (this._boundKeyDownHandler) window.removeEventListener('keydown', this._boundKeyDownHandler);\r\n    if (this._boundKeyUpHandler) window.removeEventListener('keyup', this._boundKeyUpHandler);\r\n    this._boundKeyDownHandler = null; // Czyścimy referencje\r\n    this._boundKeyUpHandler = null;\r\n\r\n    // Ukrywamy cały interfejs gry\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideGameUI();\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideQuestion();\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideFloorSelectionUI();\r\n\r\n    if (win) {\r\n      // Rysujemy ekran zwycięstwa\r\n      requestAnimationFrame(() => this.renderer?.drawWinScreen());\r\n    } else {\r\n      // W przypadku przegranej/błędu pokazujemy menu główne\r\n      // Komunikat o błędzie powinien już zostać pokazany przez _handleFatalError\r\n      const menuContainer = document.getElementById('menu-container');\r\n      if (menuContainer) menuContainer.style.display = 'flex'; // Używamy flex do centrowania\r\n    }\r\n    console.log(`[Game] Koniec Gry. Wygrana: ${win}`);\r\n  }\r\n\r\n  // Wymuszone zatrzymanie gry (np. przy wyjściu z gry)\r\n  stopGame() {\r\n    console.log('[Game] Zażądano jawnego zatrzymania.');\r\n    this._setGameOver(false); // Kończymy grę jako przegraną/zatrzymanie\r\n\r\n    // Usuwamy ogólne nasłuchiwacze (jeśli nie zostały dodane w startGame)\r\n    window.removeEventListener('resize', () => this.renderer?.resizeCanvas());\r\n\r\n    // Zwalniamy zasoby (opcjonalne, ale dobre dla garbage collectora)\r\n    this.character = null;\r\n    this.level = null;\r\n    this.inputManager = null;\r\n    this.renderer = null;\r\n    this.gameplayManager = null;\r\n    this.ctx = null;\r\n    this.canvas = null; // Referencja do elementu pozostaje, ale nie jest już używana w grze\r\n    console.log('[Game] Gra zatrzymana, komponenty potencjalnie wyczyszczone.');\r\n  }\r\n\r\n  // Obsługa błędów krytycznych (fatal error)\r\n  _handleFatalError(message, showAlert = true) {\r\n    console.error('[Game] BŁĄD KRYTYCZNY:', message);\r\n    // Pokazujemy alert tylko jeśli zażądano i gra jeszcze się nie zakończyła\r\n    if (showAlert && this.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.GAME_OVER) {\r\n      alert(message);\r\n    }\r\n    // Kończymy grę jako przegraną\r\n    this._setGameOver(false);\r\n  }\r\n\r\n  // --- Handlery (obsługa) wejścia ---\r\n  handleKeyDown(e) {\r\n    // Ignorujemy wejście, jeśli gra nie jest w stanie PLAYING lub brakuje inputManager\r\n    if (this.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.PLAYING || !this.inputManager) return;\r\n\r\n    let keyHandled = false; // Flaga zapobiegająca domyślnemu zachowaniu przeglądarki\r\n    const key = e.key.toLowerCase();\r\n\r\n    // Mapowanie klawiszy na akcje\r\n    if (key === 'arrowup' || key === 'w') {\r\n      this.inputManager.setKey('up', true);\r\n      keyHandled = true;\r\n    } else if (key === 'arrowdown' || key === 's') {\r\n      this.inputManager.setKey('down', true);\r\n      keyHandled = true;\r\n    } else if (key === 'arrowleft' || key === 'a') {\r\n      this.inputManager.setKey('left', true);\r\n      keyHandled = true;\r\n    } else if (key === 'arrowright' || key === 'd') {\r\n      this.inputManager.setKey('right', true);\r\n      keyHandled = true;\r\n    }\r\n\r\n    // Zapobiegamy przewijaniu strony strzałkami, jeśli klawisz został obsłużony\r\n    if (keyHandled) e.preventDefault();\r\n  }\r\n\r\n  handleKeyUp(e) {\r\n    // Zawsze obsługujemy puszczenie klawiszy, aby zresetować stan\r\n    if (!this.inputManager) return;\r\n    const key = e.key.toLowerCase();\r\n\r\n    if (key === 'arrowup' || key === 'w') {\r\n      this.inputManager.setKey('up', false);\r\n    } else if (key === 'arrowdown' || key === 's') {\r\n      this.inputManager.setKey('down', false);\r\n    } else if (key === 'arrowleft' || key === 'a') {\r\n      this.inputManager.setKey('left', false);\r\n    } else if (key === 'arrowright' || key === 'd') {\r\n      this.inputManager.setKey('right', false);\r\n    }\r\n  }\r\n\r\n  // --- Główna pętla gry ---\r\n  gameLoop(timestamp) {\r\n    // Wychodzimy z pętli, jeśli gra jest zatrzymana lub zakończona\r\n    if (!this.isRunning || this.gameState === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.GAME_OVER) {\r\n      return;\r\n    }\r\n\r\n    // 1. Aktualizacja logiki gry (ruch, interakcje)\r\n    this.gameplayManager?.update(timestamp);\r\n\r\n    // 2. Centrowanie kamery (po aktualizacji pozycji postaci)\r\n    this.renderer?.centerCameraOnCharacter();\r\n\r\n    // 3. Rysowanie bieżącej klatki\r\n    this.renderer?.drawFrame();\r\n\r\n    // 4. Żądanie następnej klatki animacji\r\n    requestAnimationFrame(this.gameLoop);\r\n  }\r\n\r\n  // --- Zarządzanie timerem cooldownu windy ---\r\n  startLiftCooldownTimer() {\r\n    clearTimeout(this.liftCooldownTimer); // Resetujemy poprzedni timer, jeśli istniał\r\n    console.log(`[Game] Uruchamianie timera cooldownu windy ${_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.LIFT_COOLDOWN_MS}ms.`);\r\n    this.liftCooldownTimer = setTimeout(() => {\r\n      this.liftCooldownActive = false; // Zdejmujemy flagę cooldownu\r\n      this.liftCooldownTimer = null; // Czyścimy ID timera\r\n      // Jeśli gra jest nadal w stanie przejścia (TRANSITIONING), oznacza to, że przejście zostało zakończone\r\n      if (this.gameState === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.TRANSITIONING) {\r\n        this.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.GameState.PLAYING); // Przywracamy stan gry (PLAYING)\r\n        _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessage(`Przybycie na piętro ${this.level?.currentFloor}`, 'success', 1500);\r\n      } else {\r\n        // Jeśli stan się zmienił (np. GAME_OVER), po prostu logujemy\r\n        console.warn(\r\n          `[Game TIMER] Cooldown windy zakończony, ale stan gry to ${this.gameState}. Nie zastosowano zmiany stanu.`\r\n        );\r\n      }\r\n    }, _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.LIFT_COOLDOWN_MS);\r\n  }\r\n} // Koniec klasy Game\r\n\n\n//# sourceURL=webpack://projectjs/./js/Core/Game.js?");

/***/ }),

/***/ "./js/Core/GameRenderer.js":
/*!*********************************!*\
  !*** ./js/Core/GameRenderer.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameRenderer: () => (/* binding */ GameRenderer)\n/* harmony export */ });\n/* harmony import */ var _Character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Character.js */ \"./js/Core/Character.js\");\n// src/core/GameRenderer.js\r\n// (No changes needed from previous provided version, assuming it was correct)\r\n // Optional for type checks\r\n\r\nclass GameRenderer {\r\n  constructor(game) {\r\n    this.game = game;\r\n    this.canvas = null;\r\n    this.ctx = null;\r\n  }\r\n\r\n  initializeCanvas() {\r\n    this.canvas = document.getElementById('game-canvas');\r\n    if (!this.canvas) throw new Error(\"[Renderer] Canvas 'game-canvas' not found!\");\r\n    this.ctx = this.canvas.getContext('2d');\r\n    if (!this.ctx) throw new Error('[Renderer] Failed to get 2D context.');\r\n    this.ctx.imageSmoothingEnabled = false;\r\n    this.resizeCanvas();\r\n    console.log('[Renderer] Canvas initialized.');\r\n    return { canvas: this.canvas, ctx: this.ctx };\r\n  }\r\n\r\n  resizeCanvas() {\r\n    if (!this.canvas) return;\r\n    this.canvas.width = window.innerWidth;\r\n    this.canvas.height = window.innerHeight;\r\n    if (this.game.character && this.game.level?.currentMap) {\r\n      this.centerCameraOnCharacter();\r\n    }\r\n    console.log(`[Renderer] Canvas resized to ${this.canvas.width}x${this.canvas.height}`);\r\n  }\r\n\r\n  centerCameraOnCharacter() {\r\n    const { character, level, canvas } = this.game;\r\n    if (character && level?.currentMap && canvas) {\r\n      level.currentMap.offsetX = Math.floor(canvas.width / 2 - character.x);\r\n      level.currentMap.offsetY = Math.floor(canvas.height / 2 - character.y);\r\n    }\r\n  }\r\n\r\n  drawFrame() {\r\n    if (!this.ctx || !this.canvas) return;\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    const map = this.game.level?.currentMap;\r\n    const char = this.game.character;\r\n    if (map) {\r\n      map.draw(this.ctx, this.game.bookImage);\r\n    }\r\n    if (char && map) {\r\n      char.draw(map.offsetX, map.offsetY);\r\n    }\r\n    // this.drawDebugInfo(); // Optional\r\n  }\r\n\r\n  drawWinScreen() {\r\n    if (!this.ctx || !this.canvas) return;\r\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.textBaseline = 'middle';\r\n    this.ctx.fillStyle = 'lime';\r\n    this.ctx.font = 'clamp(32px, 8vw, 48px) \"Press Start 2P\", cursive, Arial';\r\n    this.ctx.fillText('ПОБЕДА!', this.canvas.width / 2, this.canvas.height / 2 - 80);\r\n    this.ctx.fillStyle = 'white';\r\n    this.ctx.font = 'clamp(24px, 5vw, 32px) Arial, sans-serif';\r\n    this.ctx.fillText(\r\n      `Вы собрали все ${this.game.targetBooksToWin} книг!`,\r\n      this.canvas.width / 2,\r\n      this.canvas.height / 2\r\n    );\r\n    this.ctx.font = 'clamp(18px, 4vw, 24px) Arial, sans-serif';\r\n    this.ctx.fillText('Университет спасен!', this.canvas.width / 2, this.canvas.height / 2 + 60);\r\n    this.ctx.font = 'clamp(14px, 3vw, 18px) Arial, sans-serif';\r\n    this.ctx.fillStyle = '#ccc';\r\n    this.ctx.fillText(\r\n      '(Обновите страницу, чтобы начать заново)',\r\n      this.canvas.width / 2,\r\n      this.canvas.height - 50\r\n    );\r\n  }\r\n\r\n  // drawDebugInfo() { ... } // Optional debug drawing\r\n}\r\n\n\n//# sourceURL=webpack://projectjs/./js/Core/GameRenderer.js?");

/***/ }),

/***/ "./js/Core/GameplayManager.js":
/*!************************************!*\
  !*** ./js/Core/GameplayManager.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameplayManager: () => (/* binding */ GameplayManager)\n/* harmony export */ });\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/constants.js */ \"./js/utils/constants.js\");\n/* harmony import */ var _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/UIManager.js */ \"./js/UI/UIManager.js\");\n/* harmony import */ var _Character_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Character.js */ \"./js/Core/Character.js\");\n// src/core/GameplayManager.js\r\n\r\n// Używamy poprawnej wielkości liter w nazwie folderu/pliku: UI/UIManager.js\r\n\r\n\r\n\r\nclass GameplayManager {\r\n  constructor(game) {\r\n    this.game = game;\r\n    // Powiąż metody, które będą używane jako callbacki\r\n    this.handleAnswer = this.handleAnswer.bind(this);\r\n    this.handleFloorSelection = this.handleFloorSelection.bind(this);\r\n  }\r\n\r\n  // Wywoływane przez pętlę gry (Game's gameLoop)\r\n  update(timestamp) {\r\n    // Aktualizuj tylko, jeśli gra jest w stanie PLAYING\r\n    if (this.game.gameState === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING) {\r\n      this.updatePlayingState(timestamp);\r\n    }\r\n  }\r\n\r\n  updatePlayingState(timestamp) {\r\n    const char = this.game.character;\r\n    // Sprawdzenie obecności wymaganych komponentów\r\n    if (!this.game.level?.currentMap || !char || !this.game.inputManager) return;\r\n\r\n    // Obsługa ruchu\r\n    const { moved } = this.handleMovement();\r\n\r\n    // Aktualizacja animacji postaci\r\n    if (char && typeof char.updateAnimation === 'function') {\r\n      char.updateAnimation(timestamp);\r\n    }\r\n\r\n    // Obsługa interakcji, tylko jeśli postać nie poruszyła się w tej klatce\r\n    // i gra jest w stanie PLAYING\r\n    if (!moved && this.game.gameState === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING) {\r\n      this.handleInteractions();\r\n    }\r\n\r\n    // ! WAŻNE: Sprawdzenie utknięcia po KAŻDEJ klatce, jeśli się nie ruszał\r\n    // Może to być nadmierne, ale może pomóc, jeśli postać powoli \"wciska się\" w ścianę\r\n    // Jednak główne sprawdzenie odbywa się po teleportacji w handleLiftTransition\r\n    // if (!moved && this.game.gameState === GameState.PLAYING) {\r\n    //    this.ensureCharacterIsOnWalkableTile(false); // Sprawdzamy, czy nie utknął\r\n    // }\r\n  }\r\n\r\n  handleMovement() {\r\n    const char = this.game.character;\r\n    const map = this.game.level.currentMap;\r\n    const input = this.game.inputManager;\r\n    if (!char || !map || !input) return { moved: false };\r\n\r\n    const direction = input.getInputDirection();\r\n    let dx = direction.x * char.speed;\r\n    let dy = direction.y * char.speed;\r\n\r\n    const intendedMove = dx !== 0 || dy !== 0;\r\n    let actualMoveX = 0;\r\n    let actualMoveY = 0;\r\n    let moved = false;\r\n\r\n    if (intendedMove) {\r\n      // Sprawdzamy możliwość ruchu osobno dla X i Y\r\n      const canMoveX = dx !== 0 && !this.checkCollision(char.x + dx, char.y);\r\n      const canMoveY = dy !== 0 && !this.checkCollision(char.x, char.y + dy);\r\n\r\n      // Ustawiamy faktyczne przesunięcie\r\n      if (canMoveX) actualMoveX = dx;\r\n      if (canMoveY) actualMoveY = dy;\r\n\r\n      // Obsługa kolizji diagonalnej: jeśli nie możemy ruszyć się po przekątnej,\r\n      // ale możemy osobno po X i Y, priorytet ma ruch poziomy.\r\n      // Ulepszona logika: próbujemy ślizgać się wzdłuż ściany\r\n      if (dx !== 0 && dy !== 0) {\r\n        // Tylko jeśli próbowaliśmy ruszyć się po przekątnej\r\n        if (this.checkCollision(char.x + dx, char.y + dy)) {\r\n          // Jeśli przekątna jest zablokowana\r\n          if (canMoveX) {\r\n            // Jeśli możemy po X, ale nie po przekątnej\r\n            actualMoveY = 0; // Ruszamy się tylko po X\r\n          } else if (canMoveY) {\r\n            // Jeśli możemy po Y, ale nie po przekątnej\r\n            actualMoveX = 0; // Ruszamy się tylko po Y\r\n          } else {\r\n            // Jeśli nie możemy ani po X, ani po Y z pozycji diagonalnej\r\n            actualMoveX = 0;\r\n            actualMoveY = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Stosujemy faktyczne przesunięcie i aktualizujemy stan\r\n      if (actualMoveX !== 0 || actualMoveY !== 0) {\r\n        char.x += actualMoveX;\r\n        char.y += actualMoveY;\r\n        moved = true;\r\n\r\n        // Aktualizujemy kierunek sprite'a postaci\r\n        if (Math.abs(actualMoveX) >= Math.abs(actualMoveY)) {\r\n          if (actualMoveX !== 0)\r\n            char.currentDirection =\r\n              actualMoveX > 0 ? _Character_js__WEBPACK_IMPORTED_MODULE_2__.Character.Direction.RIGHT : _Character_js__WEBPACK_IMPORTED_MODULE_2__.Character.Direction.LEFT;\r\n        } else {\r\n          if (actualMoveY !== 0)\r\n            char.currentDirection =\r\n              actualMoveY > 0 ? _Character_js__WEBPACK_IMPORTED_MODULE_2__.Character.Direction.DOWN : _Character_js__WEBPACK_IMPORTED_MODULE_2__.Character.Direction.UP;\r\n        }\r\n\r\n        // ! Dodatkowe sprawdzenie PO ruchu, aby wypchnąć, jeśli lekko weszliśmy w ścianę\r\n        // this.ensureCharacterIsOnWalkableTile(false);\r\n      }\r\n    }\r\n\r\n    // Ustawiamy flagę ruchu dla animacji\r\n    char.isMoving = moved;\r\n    return { moved };\r\n  }\r\n\r\n  checkCollision(targetX, targetY) {\r\n    const map = this.game.level?.currentMap;\r\n    const char = this.game.character;\r\n    if (!map || !char) return true; // Uznajemy za kolizję, jeśli brakuje mapy lub postaci\r\n\r\n    const collisionBox = char.getCollisionBox(targetX, targetY);\r\n\r\n    // Kluczowe punkty kolidera do sprawdzenia\r\n    const pointsToCheck = [\r\n      { x: collisionBox.left, y: collisionBox.top }, // Lewy górny\r\n      { x: collisionBox.right, y: collisionBox.top }, // Prawy górny\r\n      { x: collisionBox.left, y: collisionBox.bottom }, // Lewy dolny\r\n      { x: collisionBox.right, y: collisionBox.bottom }, // Prawy dolny\r\n      { x: targetX, y: collisionBox.bottom }, // Środek dolny (ważne dla wąskich przejść)\r\n      { x: targetX, y: collisionBox.top }, // Środek górny\r\n      { x: collisionBox.left, y: targetY + char.renderSize * char.collisionBoxFeetOffsetRatio }, // Środek lewy (na poziomie stóp)\r\n      { x: collisionBox.right, y: targetY + char.renderSize * char.collisionBoxFeetOffsetRatio }, // Środek prawy (na poziomie stóp)\r\n    ];\r\n\r\n    // Sprawdzamy każdy punkt\r\n    for (const point of pointsToCheck) {\r\n      // Używamy metody mapy isWalkable do sprawdzenia przechodności punktu\r\n      if (!map.isWalkable(point.x, point.y)) {\r\n        // console.log(`Wykryto kolizję w świecie (${point.x.toFixed(1)}, ${point.y.toFixed(1)})`);\r\n        return true; // Znaleziono kolizję\r\n      }\r\n    }\r\n\r\n    return false; // Kolizji nie znaleziono\r\n  }\r\n\r\n  handleInteractions() {\r\n    const map = this.game.level?.currentMap;\r\n    const char = this.game.character;\r\n    if (!map || !char || this.game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING) return;\r\n\r\n    // 1. Sprawdzenie książek\r\n    const nearbyBook = map.findNearbyUnansweredBook(char.x, char.y);\r\n    if (nearbyBook) {\r\n      this.initiateQuestion(nearbyBook);\r\n      return; // Wychodzimy, ponieważ interakcja z książką się rozpoczęła\r\n    }\r\n\r\n    // 2. Sprawdzenie windy (tylko jeśli cooldown nie jest aktywny)\r\n    if (!this.game.liftCooldownActive) {\r\n      const nearbyLift = map.findNearbyLift(char.x, char.y);\r\n      if (nearbyLift) {\r\n        this.initiateFloorSelection();\r\n        // Nie potrzeba return, ponieważ initiateFloorSelection tylko pokazuje UI\r\n      }\r\n    }\r\n  }\r\n\r\n  initiateQuestion(book) {\r\n    if (this.game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING) return;\r\n\r\n    this.game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.ASKING_QUESTION);\r\n    if (this.game.character) this.game.character.isMoving = false; // Zatrzymujemy postać\r\n    this.game.currentBookTarget = book; // Zapamiętujemy książkę\r\n\r\n    // Aktualizujemy listę dostępnych pytań, jeśli jest pusta\r\n    if (this.game.availableQuestions.length === 0) {\r\n      this.game.availableQuestions = [..._utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.questions]; // Kopiujemy pierwotny array\r\n      if (this.game.availableQuestions.length === 0) {\r\n        // Skrajny przypadek: pytania się skończyły również w pierwotnym arrayu\r\n        _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessage('Błąd: Brak dostępnych pytań!', 'error');\r\n        this.game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING);\r\n        this.game.currentBookTarget = null;\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Wybieramy losowe pytanie spośród dostępnych\r\n    const qIndex = Math.floor(Math.random() * this.game.availableQuestions.length);\r\n    this.game.currentQuestionData = this.game.availableQuestions.splice(qIndex, 1)[0]; // Wyciągamy pytanie\r\n\r\n    // Pokazujemy UI pytania (UIManager wywoła handleAnswer tego managera)\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.showQuestion(this.game.currentQuestionData);\r\n  }\r\n\r\n  handleAnswer(selectedOptionIndex) {\r\n    const { gameState, currentQuestionData, currentBookTarget, level } = this.game;\r\n\r\n    // Sprawdzenie, czy jesteśmy w odpowiednim stanie i czy są dane pytania/książki\r\n    if (gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.ASKING_QUESTION || !currentQuestionData || !currentBookTarget) {\r\n      _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideQuestion(); // Na wszelki wypadek ukrywamy UI\r\n      this.game.currentBookTarget = null;\r\n      this.game.currentQuestionData = null;\r\n      // Wracamy do gry, tylko jeśli gra nie jest zakończona\r\n      if (this.game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.GAME_OVER) this.game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING);\r\n      return;\r\n    }\r\n\r\n    const isCorrect = selectedOptionIndex === currentQuestionData.correctAnswer;\r\n\r\n    if (isCorrect) {\r\n      _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessage('Prawidłowo!', 'success', 1500);\r\n      // Oznaczamy książkę jako zebraną na mapie\r\n      const collected = level?.currentMap?.markBookAsCollected(currentBookTarget);\r\n      if (collected) {\r\n        this.game.totalBooksCollectedGlobally++;\r\n        _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.updateScore(this.game.totalBooksCollectedGlobally, this.game.targetBooksToWin);\r\n        // Sprawdzenie warunku zwycięstwa\r\n        if (this.game.totalBooksCollectedGlobally >= this.game.targetBooksToWin) {\r\n          _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideQuestion(); // Ukryj UI przed ekranem zwycięstwa\r\n          this.game._setGameOver(true); // Wywołujemy zakończenie gry zwycięstwem\r\n          return; // Wyjście, ponieważ gra zakończona\r\n        }\r\n      } else {\r\n        _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessage('Błąd zbierania książki!', 'error');\r\n      }\r\n    } else {\r\n      _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessage('Nieprawidłowa odpowiedź!', 'error');\r\n      // Zwracamy pytanie, na które odpowiedziano nieprawidłowo, z powrotem do puli\r\n      this.game.availableQuestions.push(currentQuestionData);\r\n    }\r\n\r\n    // Ukrywamy UI pytania i resetujemy stan\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideQuestion();\r\n    this.game.currentBookTarget = null;\r\n    this.game.currentQuestionData = null;\r\n    // Wracamy do gry, tylko jeśli gra nie jest zakończona\r\n    if (this.game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.GAME_OVER) {\r\n      this.game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING);\r\n    }\r\n  }\r\n\r\n  initiateFloorSelection() {\r\n    // Nie można wywołać windy podczas pytania, przejścia lub jeśli cooldown jest aktywny\r\n    if (this.game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING || this.game.liftCooldownActive) return;\r\n\r\n    this.game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.SELECTING_FLOOR);\r\n    if (this.game.character) this.game.character.isMoving = false; // Zatrzymujemy postać\r\n\r\n    // Pokazujemy UI wyboru piętra (UIManager wywoła handleFloorSelection)\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.showFloorSelectionUI(\r\n      this.game.level.minFloor,\r\n      this.game.level.maxFloor,\r\n      this.game.level.currentFloor\r\n    );\r\n  }\r\n\r\n  handleFloorSelection(selectedFloor) {\r\n    // Sprawdzenie, czy jesteśmy w stanie wyboru piętra\r\n    if (this.game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.SELECTING_FLOOR) {\r\n      _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideFloorSelectionUI(); // Ukrywamy UI na wszelki wypadek\r\n      return;\r\n    }\r\n\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideFloorSelectionUI(); // Ukrywamy UI wyboru\r\n\r\n    // Sprawdzenie, czy wybrano inne, prawidłowe piętro\r\n    if (\r\n      selectedFloor === this.game.level.currentFloor ||\r\n      selectedFloor < this.game.level.minFloor ||\r\n      selectedFloor > this.game.level.maxFloor\r\n    ) {\r\n      // Jeśli wybrano bieżące lub nieprawidłowe piętro, po prostu wracamy do gry\r\n      this.game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING);\r\n      return;\r\n    }\r\n\r\n    // Uruchamiamy asynchroniczny proces przejścia na inne piętro\r\n    this.handleLiftTransition(selectedFloor).catch((err) => {\r\n      // Łapiemy błędy przejścia i traktujemy jako krytyczne\r\n      this.game._handleFatalError(`Błąd przejścia na piętro: ${err.message}`);\r\n    });\r\n  }\r\n\r\n  async handleLiftTransition(targetFloor) {\r\n    const game = this.game; // Skrót dla wygody\r\n\r\n    // Dodatkowe sprawdzenie stanu i cooldownu\r\n    if (game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.SELECTING_FLOOR || game.liftCooldownActive) {\r\n      // Jeśli stan już nie jest SELECTING_FLOOR (np. już TRANSITIONING lub PLAYING), wychodzimy\r\n      // Wracamy do PLAYING tylko jeśli gra nie jest zakończona i nie jest w trakcie przejścia\r\n      if (\r\n        game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.GAME_OVER &&\r\n        game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING &&\r\n        game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.TRANSITIONING\r\n      ) {\r\n        game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // --- Początek przejścia ---\r\n    game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.TRANSITIONING);\r\n    if (game.character) game.character.isMoving = false; // Zatrzymujemy postać\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideQuestion(); // Ukrywamy UI pytania, jeśli było otwarte\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.hideFloorSelectionUI(); // Upewniamy się jeszcze raz, że UI wyboru piętra jest ukryty\r\n    game.liftCooldownActive = true; // Aktywujemy cooldown\r\n    _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessage(`Przejście na piętro ${targetFloor}...`, 'info', _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIFT_COOLDOWN_MS - 200); // Komunikat o przejściu\r\n\r\n    try {\r\n      // 1. Asynchronicznie ładujemy mapę nowego piętra\r\n      await game.level.loadFloor(targetFloor, game.canvas.width, game.canvas.height);\r\n      const newMap = game.level.currentMap;\r\n      if (!newMap) {\r\n        throw new Error(\r\n          `Nie udało się załadować mapy dla piętra ${targetFloor}. Obiekt mapy jest null.`\r\n        );\r\n      }\r\n\r\n      // 2. Pobieramy pozycję windy na nowej mapie\r\n      const liftPos = newMap.getLiftPosition();\r\n      if (!liftPos) {\r\n        throw new Error(`Brak pozycji windy na załadowanym piętrze ${targetFloor}!`);\r\n      }\r\n\r\n      // 3. --- ZMIANA: Znajdź bezpieczne miejsce obok windy ---\r\n      // Szukamy najbliższej bezpiecznej (korytarz/pokój) kratki wokół windy\r\n      const safeSpawnTile = newMap.findNearestWalkableTile(\r\n        liftPos.x,\r\n        liftPos.y,\r\n        3, // Mały promień początkowy\r\n        true // EXCLUDE_LIFT - Nie chcemy lądować na samej windzie\r\n      );\r\n\r\n      if (!safeSpawnTile) {\r\n        // Jeśli nie znaleziono blisko, szukamy gdziekolwiek (ale nie windy)\r\n        console.warn(\r\n          `[LiftTransition] Nie znaleziono bezpiecznego miejsca obok windy na (${liftPos.tileX}, ${liftPos.tileY}). Szukam losowego...`\r\n        );\r\n        const emergencySpawn = newMap.findRandomInitialSpawnPosition(); // Ta funkcja już wyklucza windę\r\n        if (!emergencySpawn) {\r\n          throw new Error(\r\n            `Nie można znaleźć ŻADNEGO bezpiecznego miejsca do lądowania na piętrze ${targetFloor}!`\r\n          );\r\n        }\r\n        game.character.x = emergencySpawn.x;\r\n        game.character.y = emergencySpawn.y;\r\n        console.log(\r\n          `[LiftTransition] Awaryjne lądowanie w losowym miejscu: (${game.character.x.toFixed(\r\n            1\r\n          )}, ${game.character.y.toFixed(1)})`\r\n        );\r\n      } else {\r\n        game.character.x = safeSpawnTile.x; // Użyj znalezionego bezpiecznego miejsca\r\n        game.character.y = safeSpawnTile.y;\r\n        console.log(\r\n          `[LiftTransition] Lądowanie obok windy w: (${game.character.x.toFixed(\r\n            1\r\n          )}, ${game.character.y.toFixed(1)})`\r\n        );\r\n      }\r\n\r\n      game.character.currentDirection = _Character_js__WEBPACK_IMPORTED_MODULE_2__.Character.Direction.DOWN; // Obracamy w dół\r\n      game.character.isMoving = false; // Upewniamy się, że nie ma animacji chodzenia\r\n\r\n      // 4. ! NATYCHMIAST centrujemy kamerę na postaci PO ustawieniu pozycji!\r\n      game.renderer?.centerCameraOnCharacter();\r\n\r\n      // 5. ! OPCJONALNIE: Dodatkowe sprawdzenie ensureCharacterIsOnWalkableTile, jeśli nadal są problemy\r\n      // this.ensureCharacterIsOnWalkableTile(false); // false, bo nie chcemy stać na windzie\r\n\r\n      // 6. Uruchamiamy timer cooldownu (on przywróci stan do PLAYING po zakończeniu)\r\n      game.startLiftCooldownTimer();\r\n    } catch (error) {\r\n      // --- Obsługa błędów przejścia ---\r\n      console.error(`[LiftTransition] Błąd podczas przejścia na piętro ${targetFloor}:`, error);\r\n      game.liftCooldownActive = false; // Resetujemy cooldown przy błędzie\r\n\r\n      // Wracamy do stanu gry, jeśli gra nie zakończyła się błędem krytycznym\r\n      if (game.gameState !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.GAME_OVER) {\r\n        game.setGameState(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING);\r\n      }\r\n      // Traktujemy błąd jako krytyczny (wywoła _setGameOver(false))\r\n      game._handleFatalError(\r\n        `Krytyczny błąd podczas przejścia na piętro ${targetFloor}: ${error.message || error}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sprawdza, czy postać znajduje się na przechodniej kratce (lub obok niej).\r\n   * Jeśli postać utknęła (kolider przecina ścianę lub środek na nieprzechodniej kratce),\r\n   * próbuje znaleźć najbliższą BEZPIECZNĄ (nie windę, nie ścianę) przechodnią kratkę\r\n   * i przenieść tam postać.\r\n   * @param {boolean} [allowStandingOnLift=false] - Jeśli true, pozycja NA płytce windy\r\n   * jest uważana za prawidłową dla początkowego sprawdzenia (używane tuż po teleportacji).\r\n   * Zazwyczaj powinno być false, aby wypchnąć postać Z windy.\r\n   */\r\n  ensureCharacterIsOnWalkableTile(allowStandingOnLift = false) {\r\n    const char = this.game.character;\r\n    const map = this.game.level?.currentMap;\r\n    if (!char || !map) return; // Wyjście, jeśli brak postaci lub mapy\r\n\r\n    const currentTileX = Math.floor(char.x / map.tileSize);\r\n    const currentTileY = Math.floor(char.y / map.tileSize);\r\n\r\n    // Pobieramy typ kafelka pod środkiem postaci (jeśli współrzędne są prawidłowe)\r\n    const currentTileValue =\r\n      currentTileX >= 0 && currentTileX < map.cols && currentTileY >= 0 && currentTileY < map.rows\r\n        ? map.map[currentTileY]?.[currentTileX] // Bezpieczny dostęp\r\n        : _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL; // Uznajemy za ścianę, jeśli poza mapą\r\n\r\n    // Sprawdzenie 1: Czy kratka pod środkiem postaci jest przechodnia?\r\n    // Używamy isWalkable, która obejmuje windę jako przechodnią.\r\n    let isCenterTileWalkableByMap = map.isWalkable(char.x, char.y);\r\n    const isLift = currentTileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT;\r\n\r\n    // Określamy, czy bieżąca pozycja jest uważana za \"bezpieczną\" do stania\r\n    // Bezpiecznie, jeśli:\r\n    // 1. Kratka jest przechodnia według mapy ORAZ nie jest windą (chyba że pozwolono)\r\n    let isSafeToStandHere = isCenterTileWalkableByMap && (!isLift || allowStandingOnLift);\r\n\r\n    // Sprawdzenie 2: Czy kolider postaci przecina jakiekolwiek nieprzechodnie kratki?\r\n    const isCollidingWithWall = this.checkCollision(char.x, char.y);\r\n\r\n    // Warunek \"wypchnięcia\":\r\n    // 1. Kolider postaci przecina ścianę (isCollidingWithWall)\r\n    // LUB\r\n    // 2. Pozycja, na której stoi, nie jest uważana za \"bezpieczną\" (isSafeToStandHere === false)\r\n    const needsNudge = isCollidingWithWall || !isSafeToStandHere;\r\n\r\n    if (needsNudge) {\r\n      console.warn(\r\n        `[AntiStuck] Postać w świecie(${char.x.toFixed(1)}, ${char.y.toFixed(\r\n          1\r\n        )}) / kratce(${currentTileX}, ${currentTileY}) utknęła (kolizja: ${isCollidingWithWall}, isSafeToStand: ${isSafeToStandHere}, tileValue: ${currentTileValue}, allowLift: ${allowStandingOnLift}). Próba wypchnięcia.`\r\n      );\r\n\r\n      // Szukamy najbliższej BEZPIECZNEJ przechodniej kratki (korytarz lub podłoga pokoju, NIE WINDA)\r\n      // Używamy współrzędnych ŚWIATA do wyszukiwania\r\n      const safeSpot = map.findNearestWalkableTile(\r\n        char.x,\r\n        char.y,\r\n        8, // Maksymalny promień wyszukiwania\r\n        true // EXCLUDE_LIFT = true - szukamy tylko korytarza/pokoju\r\n      );\r\n\r\n      if (safeSpot) {\r\n        // Jeśli znaleźliśmy bezpieczne miejsce, przenosimy tam postać\r\n        console.log(\r\n          `[AntiStuck] Wypychamy postać do bezpiecznego miejsca: świat(${safeSpot.x.toFixed(\r\n            1\r\n          )}, ${safeSpot.y.toFixed(1)})`\r\n        );\r\n        char.x = safeSpot.x;\r\n        char.y = safeSpot.y;\r\n        // WAŻNE: Ponownie centrujemy kamerę PO wypchnięciu\r\n        this.game.renderer?.centerCameraOnCharacter();\r\n      } else {\r\n        // Jeśli nie znaleziono bezpiecznego miejsca (bardzo rzadki i zły przypadek)\r\n        console.error(\r\n          `[AntiStuck] BŁĄD KRYTYCZNY: Nie udało się znaleźć bezpiecznego przechodniego miejsca (korytarz/pokój) w pobliżu kratki (${currentTileX}, ${currentTileY})! Postać może pozostać w teksturze.`\r\n        );\r\n        // Wariant awaryjny: Spróbujmy znaleźć JAKIEKOLWIEK przechodnie miejsce (w tym windę) jako ostatnią deskę ratunku\r\n        // Używamy findRandomInitialSpawnPosition jako wyszukiwania losowej NIE-ŚCIANY\r\n        const emergencySpot = map.findRandomInitialSpawnPosition(); // Szuka korytarza lub podłogi (już wyklucza windę)\r\n        if (emergencySpot) {\r\n          console.warn(\r\n            `[AntiStuck] Wyjście awaryjne: Przenosimy na LOSOWĄ bezpieczną kratkę świat(${emergencySpot.x.toFixed(\r\n              1\r\n            )}, ${emergencySpot.y.toFixed(1)})`\r\n          );\r\n          char.x = emergencySpot.x;\r\n          char.y = emergencySpot.y;\r\n          this.game.renderer?.centerCameraOnCharacter();\r\n        } else {\r\n          // Jeśli nawet losowej nie udało się znaleźć - całkowita katastrofa\r\n          console.error(\r\n            '[AntiStuck] W ogóle nie znaleziono bezpiecznych kratek! Gra może być zepsuta.'\r\n          );\r\n          this.game._handleFatalError(\r\n            'Błąd krytyczny: Nie można znaleźć bezpiecznego miejsca dla postaci!'\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Koniec klasy GameplayManager\r\n\n\n//# sourceURL=webpack://projectjs/./js/Core/GameplayManager.js?");

/***/ }),

/***/ "./js/Core/InputManager.js":
/*!*********************************!*\
  !*** ./js/Core/InputManager.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputManager: () => (/* binding */ InputManager)\n/* harmony export */ });\n// src/core/InputManager.js\r\nclass InputManager {\r\n  constructor() {\r\n    this.keys = {\r\n      up: false,\r\n      down: false,\r\n      left: false,\r\n      right: false,\r\n    };\r\n  }\r\n\r\n  setKey(key, isPressed) {\r\n    if (this.keys.hasOwnProperty(key)) {\r\n      this.keys[key] = isPressed;\r\n    }\r\n  }\r\n\r\n  getInputDirection() {\r\n    let x = 0;\r\n    let y = 0;\r\n    if (this.keys.up) y -= 1;\r\n    if (this.keys.down) y += 1;\r\n    if (this.keys.left) x -= 1;\r\n    if (this.keys.right) x += 1;\r\n    return { x, y };\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://projectjs/./js/Core/InputManager.js?");

/***/ }),

/***/ "./js/Core/Level.js":
/*!**************************!*\
  !*** ./js/Core/Level.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Level: () => (/* binding */ Level)\n/* harmony export */ });\n/* harmony import */ var _map_ProceduralMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../map/ProceduralMap.js */ \"./js/map/ProceduralMap.js\");\n// src/core/Level.js\r\n\r\n// Removed TRANSITION_ZONE_RADIUS_MULTIPLIER import\r\n\r\n/**\r\n * Класс Level управляет текущим этажом и загрузкой карт.\r\n * Логика зон перехода (transition zones) удалена, т.к. лифт работает иначе.\r\n */\r\nclass Level {\r\n  /**\r\n   * Создает экземпляр Level.\r\n   * @param {number} [minFloor=1] - Номер самого нижнего этажа.\r\n   * @param {number} [maxFloor=3] - Номер самого верхнего этажа.\r\n   */\r\n  constructor(minFloor = 1, maxFloor = 3) {\r\n    if (minFloor >= maxFloor) {\r\n      console.warn(\r\n        `Level constructor: minFloor (${minFloor}) must be less than maxFloor (${maxFloor}). Using defaults 1 and 3.`\r\n      );\r\n      this.minFloor = 1;\r\n      this.maxFloor = 3;\r\n    } else {\r\n      this.minFloor = minFloor;\r\n      this.maxFloor = maxFloor;\r\n    }\r\n\r\n    this.currentFloor = this.minFloor;\r\n    this.currentMap = null; // Instance of ProceduralMap\r\n    // this.transitionZones = []; // REMOVED - No longer needed for lifts\r\n    this.tileSize = 32; // Default, will be updated from map\r\n  }\r\n\r\n  /**\r\n   * Асинхронно загружает (генерирует) карту для указанного этажа.\r\n   * Assumes ProceduralMap constructor handles generation, lift placement,\r\n   * and throws on critical failure (e.g., unreachable lift).\r\n   * @param {number} floorNumber - Номер этажа для загрузки.\r\n   * @param {number} canvasWidth - Ширина канваса.\r\n   * @param {number} canvasHeight - Высота канваса.\r\n   * @returns {Promise<void>} Промис, который разрешается после загрузки этажа.\r\n   * @throws {Error} If ProceduralMap generation or validation fails.\r\n   */\r\n  async loadFloor(floorNumber, canvasWidth, canvasHeight) {\r\n    if (floorNumber < this.minFloor || floorNumber > this.maxFloor) {\r\n      const errorMsg = `Attempted to load invalid floor: ${floorNumber}. Allowed range: [${this.minFloor}-${this.maxFloor}]`;\r\n      console.error(`[Level] ${errorMsg}`);\r\n      throw new Error(errorMsg);\r\n    }\r\n\r\n    console.log(`[Level] Loading floor ${floorNumber}...`);\r\n    this.currentFloor = floorNumber;\r\n\r\n    try {\r\n      // ProceduralMap constructor now handles generation AND validation (like lift reachability).\r\n      // It will throw an error if generation fails critically.\r\n      this.currentMap = new _map_ProceduralMap_js__WEBPACK_IMPORTED_MODULE_0__.ProceduralMap(\r\n        canvasWidth,\r\n        canvasHeight,\r\n        this.currentFloor,\r\n        this.minFloor,\r\n        this.maxFloor\r\n      );\r\n\r\n      // Basic validation after creation (ensure map object looks reasonable)\r\n      if (\r\n        !this.currentMap.tileSize ||\r\n        !this.currentMap.map ||\r\n        !this.currentMap.books || // books should exist (even if empty)\r\n        !this.currentMap.getLiftPosition() // Lift position MUST exist after successful generation\r\n      ) {\r\n        throw new Error(\r\n          '[Level] ProceduralMap instance is missing essential properties after creation (tileSize, map, books, or liftPosition).'\r\n        );\r\n      }\r\n\r\n      this.tileSize = this.currentMap.tileSize;\r\n      const liftPos = this.currentMap.getLiftPosition();\r\n      console.log(\r\n        `  [Level] Map generated for floor ${this.currentFloor}. TileSize: ${this.tileSize}. Lift at tile(${liftPos.tileX}, ${liftPos.tileY}).`\r\n      );\r\n\r\n      // REMOVED: createTransitionZones() call is no longer needed.\r\n\r\n      console.log(\r\n        `[Level] Floor ${floorNumber} loaded successfully. Map size: ${this.currentMap.cols}x${this.currentMap.rows}. ${this.currentMap.books.length} books placed.`\r\n      );\r\n    } catch (error) {\r\n      console.error(\r\n        `[Level] CRITICAL FAILURE loading floor ${floorNumber}: Failed to create or validate ProceduralMap:`,\r\n        error\r\n      );\r\n      this.currentMap = null; // Ensure state is clean on failure\r\n      // Rethrow the error for Game.js to handle (likely show error message and stop)\r\n      throw new Error(\r\n        `Map generation/validation failed for floor ${floorNumber}. ${error.message || error}`\r\n      );\r\n    }\r\n\r\n    // Return a resolved promise (generation itself is synchronous within the constructor)\r\n    return Promise.resolve();\r\n  }\r\n\r\n  // REMOVED: createTransitionZones() method is obsolete.\r\n\r\n  // REMOVED: getCurrentTransitionZone() method is obsolete. Lift interaction checked differently.\r\n\r\n  /**\r\n   * Возвращает массив объектов книг на текущей карте.\r\n   * @returns {Array<object>} Массив объектов книг.\r\n   */\r\n  getCurrentBooks() {\r\n    return this.currentMap ? this.currentMap.books : [];\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://projectjs/./js/Core/Level.js?");

/***/ }),

/***/ "./js/UI/UIManager.js":
/*!****************************!*\
  !*** ./js/UI/UIManager.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIManager: () => (/* binding */ UIManager)\n/* harmony export */ });\n// src/UI/UIManager.js <-- UPEWNIJ SIĘ, ŻE ŚCIEŻKA I WIELKOŚĆ LITER SĄ POPRAWNE\r\n\r\n// *** WAŻNE: IMPORTY STAŁYCH ITP. POWINNY BYĆ TUTAJ, JEŚLI SĄ POTRZEBNE ***\r\n// import { GameState, ... } from '../utils/constants.js'; // Przykład\r\n\r\nclass UIManager {\r\n  // --- Static Properties for Element References ---\r\n  static scoreElement = null;\r\n  static targetElement = null;\r\n  static controlsContainer = null;\r\n  static questionOverlay = null;\r\n  static questionTextElement = null;\r\n  static answerButtonsContainer = null;\r\n  static floorSelectionPanel = null;\r\n  static floorButtonsContainer = null;\r\n  static flashMessageContainer = null;\r\n  static gameUIContainer = null;\r\n\r\n  // --- Static Properties for State/Callbacks ---\r\n  // static currentAnswerCallback = null; // REMOVED - Use gameplayManagerInstance\r\n  // static floorSelectionCallback = null; // REMOVED - Use gameplayManagerInstance\r\n  static gameplayManagerInstance = null; // NEW: Reference to GameplayManager\r\n  static flashMessageTimeout = null;\r\n\r\n  /**\r\n   * ! WAŻNE: Wywołaj tę metodę z Game.js po utworzeniu GameplayManager !\r\n   * Rejestruje instancję GameplayManager do obsługi callbacków UI.\r\n   * @param {GameplayManager} manager - Instancja GameplayManager.\r\n   */\r\n  static setGameplayManager(manager) {\r\n    if (!manager) {\r\n      console.error('[UIManager] Próbowano ustawić instancję GameplayManager jako null!');\r\n      return;\r\n    }\r\n    this.gameplayManagerInstance = manager;\r\n    console.log('[UIManager] Instancja GameplayManager zarejestrowana pomyślnie.');\r\n  }\r\n\r\n  /** Tworzy lub znajduje kontrolki i wyświetlanie wyniku */\r\n  static createControls(inputManager) {\r\n    // --- Controls Container ---\r\n    this.controlsContainer = document.getElementById('controls-container');\r\n    if (!this.controlsContainer) {\r\n      this.controlsContainer = document.createElement('div');\r\n      this.controlsContainer.id = 'controls-container';\r\n      this.controlsContainer.classList.add('controls-container');\r\n      document.body.appendChild(this.controlsContainer);\r\n    }\r\n    this.controlsContainer.innerHTML = ''; // Wyczyść poprzednie\r\n\r\n    const arrows = [\r\n      { direction: 'up', icon: '↑', gridArea: 'up' },\r\n      { direction: 'left', icon: '←', gridArea: 'left' },\r\n      { direction: 'right', icon: '→', gridArea: 'right' },\r\n      { direction: 'down', icon: '↓', gridArea: 'down' },\r\n    ];\r\n\r\n    arrows.forEach(({ direction, icon, gridArea }) => {\r\n      const btn = document.createElement('button');\r\n      btn.className = `control-btn ${direction}`;\r\n      btn.textContent = icon;\r\n      btn.style.gridArea = gridArea;\r\n      const startPress = (e) => {\r\n        if (inputManager?.keys.hasOwnProperty(direction)) {\r\n          inputManager.setKey(direction, true);\r\n          btn.classList.add('active');\r\n        }\r\n        e.preventDefault();\r\n      };\r\n      const endPress = (e) => {\r\n        if (inputManager?.keys.hasOwnProperty(direction)) {\r\n          if (inputManager.keys[direction]) inputManager.setKey(direction, false); // Zwolnij tylko, jeśli naciśnięty przez manager\r\n          btn.classList.remove('active');\r\n        }\r\n        e.preventDefault();\r\n      };\r\n      btn.addEventListener('touchstart', startPress, { passive: false });\r\n      btn.addEventListener('touchend', endPress, { passive: false });\r\n      btn.addEventListener('touchcancel', endPress, { passive: false });\r\n      btn.addEventListener('mousedown', startPress);\r\n      btn.addEventListener('mouseup', endPress);\r\n      btn.addEventListener('mouseleave', endPress);\r\n      this.controlsContainer.appendChild(btn);\r\n    });\r\n    this.controlsContainer.style.display = 'none'; // Ukryj początkowo\r\n\r\n    // --- Score Element ---\r\n    // (Logika wyszukiwania/tworzenia elementów wyniku pozostała bez zmian)\r\n    this.scoreElement = document.getElementById('score-value');\r\n    this.targetElement = document.getElementById('score-target');\r\n    const scoreDisplayContainer = document.getElementById('score-display');\r\n    if (!scoreDisplayContainer) {\r\n      const scoreDiv = document.createElement('div');\r\n      scoreDiv.id = 'score-display';\r\n      scoreDiv.classList.add('score-display');\r\n      scoreDiv.innerHTML = `Książki: <span id=\"score-value\">0</span> / <span id=\"score-target\">?</span>`; // Zmieniono \"Книги\" na \"Książki\"\r\n      document.body.appendChild(scoreDiv);\r\n      this.scoreElement = document.getElementById('score-value');\r\n      this.targetElement = document.getElementById('score-target');\r\n    } else {\r\n      if (this.scoreElement) this.scoreElement.textContent = '0';\r\n      if (this.targetElement) this.targetElement.textContent = '?';\r\n    }\r\n    if (scoreDisplayContainer) scoreDisplayContainer.style.display = 'none';\r\n  }\r\n\r\n  /** Tworzy lub znajduje elementy nakładki pytania */\r\n  static createQuestionUI() {\r\n    this.questionOverlay = document.getElementById('question-overlay');\r\n    if (!this.questionOverlay) {\r\n      this.questionOverlay = document.createElement('div');\r\n      this.questionOverlay.id = 'question-overlay';\r\n      this.questionOverlay.classList.add('ui-panel');\r\n      const questionBox = document.createElement('div');\r\n      questionBox.id = 'question-box';\r\n      this.questionTextElement = document.createElement('p');\r\n      this.questionTextElement.id = 'question-text';\r\n      this.answerButtonsContainer = document.createElement('div');\r\n      this.answerButtonsContainer.id = 'answer-buttons';\r\n      questionBox.appendChild(this.questionTextElement);\r\n      questionBox.appendChild(this.answerButtonsContainer);\r\n      this.questionOverlay.appendChild(questionBox);\r\n      document.body.appendChild(this.questionOverlay);\r\n    } else {\r\n      this.questionTextElement = document.getElementById('question-text');\r\n      this.answerButtonsContainer = document.getElementById('answer-buttons');\r\n    }\r\n    if (!this.questionTextElement || !this.answerButtonsContainer)\r\n      console.error('[UIManager] Nie udało się znaleźć/utworzyć potomnych elementów UI pytania!');\r\n    this.questionOverlay.style.display = 'none';\r\n  }\r\n\r\n  /** Tworzy lub znajduje nakładkę wyboru piętra */\r\n  static createFloorSelectionUI() {\r\n    this.floorSelectionPanel = document.getElementById('floor-selection-ui');\r\n    if (!this.floorSelectionPanel) {\r\n      this.floorSelectionPanel = document.createElement('div');\r\n      this.floorSelectionPanel.id = 'floor-selection-ui';\r\n      this.floorSelectionPanel.classList.add('ui-panel');\r\n      const title = document.createElement('h2');\r\n      title.textContent = 'Wybór piętra'; // Zmieniono \"Выбор этажа\" na \"Wybór piętra\"\r\n      this.floorButtonsContainer = document.createElement('div');\r\n      this.floorButtonsContainer.id = 'floor-buttons-container';\r\n      this.floorSelectionPanel.appendChild(title);\r\n      this.floorSelectionPanel.appendChild(this.floorButtonsContainer);\r\n      document.body.appendChild(this.floorSelectionPanel);\r\n    } else {\r\n      this.floorButtonsContainer = document.getElementById('floor-buttons-container');\r\n    }\r\n    if (!this.floorButtonsContainer)\r\n      console.error('[UIManager] Nie udało się znaleźć/utworzyć kontenera przycisków pięter!');\r\n    this.floorSelectionPanel.style.display = 'none';\r\n  }\r\n\r\n  /** Zapewnia istnienie kontenera komunikatów flash */\r\n  static ensureFlashMessageContainer() {\r\n    if (!this.flashMessageContainer) {\r\n      this.flashMessageContainer = document.getElementById('flash-message-container');\r\n      if (!this.flashMessageContainer) {\r\n        this.flashMessageContainer = document.createElement('div');\r\n        this.flashMessageContainer.id = 'flash-message-container';\r\n        this.flashMessageContainer.classList.add('flash-message');\r\n        this.flashMessageContainer.style.display = 'none';\r\n        document.body.appendChild(this.flashMessageContainer);\r\n      }\r\n    }\r\n    return this.flashMessageContainer;\r\n  }\r\n\r\n  /**\r\n   * Pokazuje UI pytania. Wywołuje GameplayManager.handleAnswer przy wyborze.\r\n   * @param {object} questionData - Obiekt pytania { question: string, options: string[], correctAnswer: number }\r\n   */\r\n  static showQuestion(questionData) {\r\n    if (\r\n      !this.questionOverlay ||\r\n      !this.questionTextElement ||\r\n      !this.answerButtonsContainer ||\r\n      !questionData\r\n    ) {\r\n      console.error('[UIManager] Nie można pokazać pytania - brakuje UI/Danych.');\r\n      return;\r\n    }\r\n    if (\r\n      !this.gameplayManagerInstance ||\r\n      typeof this.gameplayManagerInstance.handleAnswer !== 'function'\r\n    ) {\r\n      console.error(\r\n        '[UIManager] Nie można pokazać pytania - GameplayManager lub metoda handleAnswer nie są ustawione!'\r\n      );\r\n      return;\r\n    }\r\n\r\n    this.questionTextElement.textContent = questionData.question;\r\n    this.answerButtonsContainer.innerHTML = ''; // Wyczyść poprzednie przyciski\r\n\r\n    questionData.options.forEach((optionText, index) => {\r\n      const button = document.createElement('button');\r\n      button.textContent = optionText;\r\n      button.dataset.index = index;\r\n      button.classList.add('answer-button');\r\n      button.addEventListener('click', (e) => {\r\n        const selectedIndex = parseInt(e.target.dataset.index, 10);\r\n        // Bezpośrednio wywołaj handler GameplayManagera\r\n        setTimeout(() => this.gameplayManagerInstance.handleAnswer(selectedIndex), 50); // Lekkie opóźnienie dla reakcji UI\r\n      });\r\n      this.answerButtonsContainer.appendChild(button);\r\n    });\r\n    this.questionOverlay.style.display = 'flex';\r\n  }\r\n\r\n  /** Ukrywa nakładkę pytania */\r\n  static hideQuestion() {\r\n    if (this.questionOverlay) this.questionOverlay.style.display = 'none';\r\n    // Wyczyść zawartość, aby zapobiec krótkotrwałemu wyświetlaniu starego pytania przy ponownym pokazaniu\r\n    if (this.questionTextElement) this.questionTextElement.textContent = '';\r\n    if (this.answerButtonsContainer) this.answerButtonsContainer.innerHTML = '';\r\n  }\r\n\r\n  /**\r\n   * Pokazuje UI wyboru piętra. Wywołuje GameplayManager.handleFloorSelection przy kliknięciu.\r\n   * @param {number} minFloor\r\n   * @param {number} maxFloor\r\n   * @param {number} currentFloor\r\n   */\r\n  static showFloorSelectionUI(minFloor, maxFloor, currentFloor) {\r\n    if (!this.floorSelectionPanel || !this.floorButtonsContainer) {\r\n      console.error('[UIManager] Nie można pokazać wyboru piętra - brak elementów UI.');\r\n      this.createFloorSelectionUI(); // Spróbuj utworzyć, jeśli brakuje\r\n      if (!this.floorSelectionPanel || !this.floorButtonsContainer) return;\r\n    }\r\n    if (\r\n      !this.gameplayManagerInstance ||\r\n      typeof this.gameplayManagerInstance.handleFloorSelection !== 'function'\r\n    ) {\r\n      console.error(\r\n        '[UIManager] Nie można pokazać wyboru piętra - GameplayManager lub metoda handleFloorSelection nie są ustawione!'\r\n      );\r\n      return;\r\n    }\r\n\r\n    this.floorButtonsContainer.innerHTML = ''; // Wyczyść poprzednie przyciski\r\n    for (let floor = minFloor; floor <= maxFloor; floor++) {\r\n      const button = document.createElement('button');\r\n      button.textContent = `Piętro ${floor}`; // Zmieniono \"Этаж\" na \"Piętro\"\r\n      button.classList.add('floor-button');\r\n      button.dataset.floor = floor;\r\n      if (floor === currentFloor) {\r\n        button.disabled = true;\r\n        button.classList.add('current');\r\n      } else {\r\n        button.addEventListener('click', () => {\r\n          // Bezpośrednio wywołaj handler GameplayManagera\r\n          this.gameplayManagerInstance.handleFloorSelection(floor);\r\n          // GameplayManager jest teraz odpowiedzialny za ukrycie tego UI\r\n        });\r\n      }\r\n      this.floorButtonsContainer.appendChild(button);\r\n    }\r\n    this.floorSelectionPanel.style.display = 'flex';\r\n  }\r\n\r\n  /** Ukrywa nakładkę wyboru piętra */\r\n  static hideFloorSelectionUI() {\r\n    if (this.floorSelectionPanel) this.floorSelectionPanel.style.display = 'none';\r\n  }\r\n\r\n  /** Aktualizuje wyświetlanie wyniku */\r\n  static updateScore(score, target) {\r\n    if (!this.scoreElement) this.scoreElement = document.getElementById('score-value');\r\n    if (!this.targetElement) this.targetElement = document.getElementById('score-target');\r\n    if (this.scoreElement) this.scoreElement.textContent = score;\r\n    if (this.targetElement) this.targetElement.textContent = target;\r\n  }\r\n\r\n  /** Pokazuje tymczasowy komunikat flash */\r\n  static flashMessage(message, type = 'info', duration = 3000) {\r\n    const container = this.ensureFlashMessageContainer();\r\n    if (!container) return;\r\n    container.textContent = message;\r\n    container.className = 'flash-message'; // Zresetuj klasy\r\n    container.classList.add(`flash-${type}`);\r\n    container.style.display = 'block';\r\n    void container.offsetWidth; // Reflow\r\n    container.style.opacity = 1;\r\n    clearTimeout(this.flashMessageTimeout);\r\n    this.flashMessageTimeout = setTimeout(() => {\r\n      container.style.opacity = 0;\r\n      const hide = () => {\r\n        container.style.display = 'none';\r\n        container.removeEventListener('transitionend', hide);\r\n      };\r\n      container.addEventListener('transitionend', hide);\r\n      setTimeout(hide, 600); // Fallback\r\n    }, duration);\r\n  }\r\n\r\n  /** Pokazuje główne elementy UI gry */\r\n  static showGameUI() {\r\n    const canvas = document.getElementById('game-canvas');\r\n    const menuContainer = document.getElementById('menu-container');\r\n    const scoreDisplay = document.getElementById('score-display');\r\n    if (canvas) canvas.style.display = 'block';\r\n    if (menuContainer) menuContainer.style.display = 'none';\r\n    if (this.controlsContainer) this.controlsContainer.style.display = 'grid';\r\n    if (scoreDisplay) scoreDisplay.style.display = 'block';\r\n    this.hideQuestion();\r\n    this.hideFloorSelectionUI(); // Upewnij się, że popupy są ukryte\r\n  }\r\n\r\n  /** Ukrywa główne elementy UI gry */\r\n  static hideGameUI() {\r\n    const canvas = document.getElementById('game-canvas');\r\n    const scoreDisplay = document.getElementById('score-display');\r\n    if (canvas) canvas.style.display = 'none';\r\n    if (this.controlsContainer) this.controlsContainer.style.display = 'none';\r\n    if (scoreDisplay) scoreDisplay.style.display = 'none';\r\n    this.hideQuestion();\r\n    this.hideFloorSelectionUI(); // Upewnij się, że popupy są ukryte\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://projectjs/./js/UI/UIManager.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Core_Game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Core/Game.js */ \"./js/Core/Game.js\");\n/* harmony import */ var _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UI/UIManager.js */ \"./js/UI/UIManager.js\");\n// src/main.js (или твой файл точки входа)\r\n // Уточни путь\r\n // Убедись, что путь и регистр верны\r\n\r\n// --- Глобальные переменные ---\r\nconst menuContainer = document.getElementById('menu-container');\r\nconst gameCanvas = document.getElementById('game-canvas');\r\nconst characterSelectorWrapper = document.getElementById('character-selector-wrapper'); // Обертка кружков\r\nconst startButton = document.getElementById('start-button');\r\n\r\nlet currentGameInstance = null;\r\nlet selectedCharacterColor = null; // Храним выбранный цвет\r\n\r\n// --- Функция старта игры ---\r\nfunction startGame() {\r\n  if (currentGameInstance) {\r\n    console.warn('Trying to start game when instance already exists.');\r\n    return;\r\n  }\r\n  if (!selectedCharacterColor) {\r\n    alert('Пожалуйста, выберите персонажа!'); // Сообщение, если цвет не выбран\r\n    return;\r\n  }\r\n\r\n  // Скрываем меню, показываем канвас\r\n  if (menuContainer) menuContainer.style.display = 'none';\r\n  if (gameCanvas) gameCanvas.style.display = 'block';\r\n  else {\r\n    console.error('Game canvas not found! Cannot start game.');\r\n    if (menuContainer) menuContainer.style.display = 'flex'; // Показать меню обратно\r\n    return;\r\n  }\r\n\r\n  console.log(`Starting game with character: ${selectedCharacterColor}`);\r\n  try {\r\n    currentGameInstance = new _Core_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game(selectedCharacterColor);\r\n    // window.game = currentGameInstance; // Для дебага\r\n  } catch (error) {\r\n    console.error('Failed to initialize game:', error);\r\n    const errorMsg = `Критическая ошибка запуска: ${error.message}`;\r\n    if (_UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessageContainer) {\r\n      _UI_UIManager_js__WEBPACK_IMPORTED_MODULE_1__.UIManager.flashMessage(errorMsg, 'error', 10000);\r\n    } else {\r\n      alert(errorMsg);\r\n    }\r\n    if (menuContainer) menuContainer.style.display = 'flex';\r\n    if (gameCanvas) gameCanvas.style.display = 'none';\r\n    currentGameInstance = null;\r\n  }\r\n}\r\n\r\n// --- Инициализация при загрузке страницы ---\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  // Настройка выбора персонажа\r\n  if (characterSelectorWrapper) {\r\n    const circles = characterSelectorWrapper.querySelectorAll('.character-circle');\r\n    circles.forEach((circle) => {\r\n      circle.addEventListener('click', (event) => {\r\n        // Снимаем выделение со всех кружков\r\n        circles.forEach((c) => c.classList.remove('selected'));\r\n        // Выделяем нажатый\r\n        event.target.classList.add('selected');\r\n        // Сохраняем выбранный цвет из data-атрибута\r\n        selectedCharacterColor = event.target.dataset.color;\r\n        console.log(`Selected character color: ${selectedCharacterColor}`);\r\n        // Активируем кнопку старта\r\n        if (startButton) {\r\n          startButton.disabled = false;\r\n        }\r\n      });\r\n    });\r\n  } else {\r\n    console.warn('Character selector wrapper not found. Using default color.');\r\n    selectedCharacterColor = 'red'; // Цвет по умолчанию, если селектора нет\r\n    // Можно сразу активировать кнопку старта или запустить игру\r\n    if (startButton) startButton.disabled = false;\r\n    // Или если кнопки старта тоже нет, запускать сразу:\r\n    // initializeGame(); // Функция для немедленного старта (см. предыдущий ответ)\r\n  }\r\n\r\n  // Настройка кнопки старта\r\n  if (startButton) {\r\n    startButton.addEventListener('click', startGame);\r\n    console.log('Start button listener added.');\r\n  } else {\r\n    console.warn('Start button not found. Game cannot be started via button.');\r\n    // Если кнопки нет, но есть выбор персонажа, игра не начнется сама\r\n    // Если нет ни того, ни другого, нужна логика автостарта (см. initializeGame выше)\r\n  }\r\n});\r\n\r\n// Опционально: обработка закрытия вкладки/окна\r\nwindow.addEventListener('beforeunload', () => {\r\n  currentGameInstance?.stopGame();\r\n});\r\n\n\n//# sourceURL=webpack://projectjs/./js/main.js?");

/***/ }),

/***/ "./js/map/Book.js":
/*!************************!*\
  !*** ./js/map/Book.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Book: () => (/* binding */ Book)\n/* harmony export */ });\n// src/map/Book.js\r\nclass Book {\r\n  constructor(x, y, id, tileSize) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.id = id;\r\n    this.tileSize = tileSize;\r\n    this.size = tileSize * 0.6;\r\n    this.collected = false;\r\n    this.isCollected = false;\r\n  }\r\n  draw(ctx, offsetX, offsetY, bookImage) {\r\n    const screenX = Math.floor(this.x + offsetX - this.size / 2);\r\n    const screenY = Math.floor(this.y + offsetY - this.size / 2);\r\n    if (bookImage) {\r\n      ctx.drawImage(bookImage, screenX, screenY, this.size, this.size);\r\n    } else {\r\n      ctx.fillStyle = '#8d6e63';\r\n      ctx.fillRect(screenX, screenY, this.size, this.size);\r\n      ctx.strokeStyle = '#5d4037';\r\n      ctx.strokeRect(screenX, screenY, this.size, this.size);\r\n      ctx.fillStyle = '#eee';\r\n      ctx.font = `${this.size * 0.6}px Arial`;\r\n      ctx.textAlign = 'center';\r\n      ctx.textBaseline = 'middle';\r\n      ctx.fillText('?', screenX + this.size / 2, screenY + this.size / 2 + 2);\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://projectjs/./js/map/Book.js?");

/***/ }),

/***/ "./js/map/MapGen.js":
/*!**************************!*\
  !*** ./js/map/MapGen.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateLevelData: () => (/* binding */ generateLevelData)\n/* harmony export */ });\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/constants.js */ \"./js/utils/constants.js\");\n/* harmony import */ var _utils_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/map.js */ \"./js/utils/map.js\");\n// src/map/mapGenerator.js\r\n\r\n\r\n // Assuming performBFS is in map.js\r\n\r\n// --- Module-level state for lift consistency ---\r\nlet consistentLiftCoords = null;\r\n\r\n// --- Generation Parameters (Defaults) ---\r\nconst DEFAULT_GEN_PARAMS = {\r\n  minRoomSize: 5,\r\n  maxRoomSize: 10,\r\n  corridorThickness: 1, // Currently hardcoded to 1 in carving funcs\r\n  numRooms: 12,\r\n  maxRoomAttempts: 200,\r\n  roomTypeWeights: {\r\n    classroom: 50,\r\n    office: 25,\r\n    library: 15,\r\n    gym: 0, // Base weight, adjusted based on floor\r\n    utility: 10,\r\n  },\r\n};\r\n\r\n// --- Core Generation Function ---\r\nfunction generateLevelData(config) {\r\n  const { cols, rows, floorNumber, minFloor, tileSize, generationParams: userParams } = config; // Added tileSize\r\n  const genParams = { ...DEFAULT_GEN_PARAMS, ...userParams };\r\n\r\n  // Adjust gym chance for the first floor\r\n  genParams.roomTypeWeights.gym = floorNumber === minFloor ? _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GYM_CHANCE_ON_FIRST_FLOOR * 100 : 0;\r\n\r\n  // Reset consistent lift coords on the first floor\r\n  if (floorNumber === minFloor) {\r\n    consistentLiftCoords = null;\r\n    console.log(`[MapGen Floor ${floorNumber}] Reset consistent lift coords for the first floor.`);\r\n  }\r\n\r\n  console.log(`[MapGen Floor ${floorNumber}] Starting map generation (${cols}x${rows})...`);\r\n  const map = Array.from({ length: rows }, () => Array(cols).fill(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL));\r\n  const rooms = [];\r\n  let liftPosition = null;\r\n\r\n  // --- Generation Steps ---\r\n  _placeRooms(map, rooms, cols, rows, genParams);\r\n\r\n  if (rooms.length < 2 && floorNumber !== minFloor) {\r\n    // Allow single room on first floor maybe? Or handle differently\r\n    console.warn(\r\n      `[MapGen Floor ${floorNumber}] Placed only ${rooms.length} rooms. Expect limited connectivity.`\r\n    );\r\n    // Consider adding a fallback: maybe connect the single room to the map edge or a random point?\r\n  } else if (rooms.length >= 2) {\r\n    _connectRoomsBetter(map, rooms, cols, rows);\r\n  }\r\n\r\n  try {\r\n    // Pass consistentLiftCoords reference, potentially update it inside\r\n    const placedLiftData = _placeLift(\r\n      map,\r\n      cols,\r\n      rows,\r\n      floorNumber,\r\n      minFloor,\r\n      tileSize,\r\n      consistentLiftCoords\r\n    ); // Pass tileSize\r\n    liftPosition = placedLiftData.position;\r\n    // Update the module-level variable if it was newly set\r\n    if (placedLiftData.coords) {\r\n      consistentLiftCoords = placedLiftData.coords;\r\n    }\r\n  } catch (error) {\r\n    console.error(`[MapGen Floor ${floorNumber}] CRITICAL: Lift placement failed:`, error);\r\n    throw new Error(`Lift placement failed on floor ${floorNumber}: ${error.message}`);\r\n  }\r\n\r\n  // Ensure borders are walls AFTER placing lift and connections\r\n  _ensureMapBorders(map, cols, rows);\r\n\r\n  // Final lift reachability check *after* potential forced connections\r\n  if (liftPosition && !_isLiftReachable(map, liftPosition, cols, rows)) {\r\n    // Attempt to force connection one last time if unreachable\r\n    console.warn(\r\n      `[MapValidation Floor ${floorNumber}] Lift at tile(${liftPosition.tileX}, ${liftPosition.tileY}) initially unreachable. Attempting final force connection.`\r\n    );\r\n    const connected = _forceConnectionToPoint(\r\n      map,\r\n      liftPosition.tileX,\r\n      liftPosition.tileY,\r\n      cols,\r\n      rows\r\n    );\r\n    if (!connected || !_isLiftReachable(map, liftPosition, cols, rows)) {\r\n      const errorMsg = `CRITICAL: Placed lift at tile(${liftPosition.tileX}, ${liftPosition.tileY}) is UNREACHABLE even after force connect! Generation failed.`;\r\n      console.error(`[MapGen Floor ${floorNumber}] ${errorMsg}`);\r\n      // Optional: Log map grid here for debugging the unreachable state\r\n      // logMapGridForDebug(map, cols, rows);\r\n      throw new Error(`Lift is unreachable on floor ${floorNumber}. Cannot proceed.`);\r\n    } else {\r\n      console.log(\r\n        `[MapValidation Floor ${floorNumber}] Lift connection successful after second attempt.`\r\n      );\r\n    }\r\n  } else if (liftPosition) {\r\n    console.log(\r\n      `[MapValidation Floor ${floorNumber}] Lift at tile(${liftPosition.tileX}, ${liftPosition.tileY}) is reachable.`\r\n    );\r\n  } else {\r\n    // This case should have been caught earlier, but double-check\r\n    throw new Error(`Map generated without a valid lift position on floor ${floorNumber}.`);\r\n  }\r\n\r\n  console.log(`[MapGen Floor ${floorNumber}] Map generation completed successfully.`);\r\n  return { map, rooms, liftPosition }; // Return the generated data\r\n}\r\n\r\n// --- Helper: Place Rooms ---\r\nfunction _placeRooms(map, rooms, cols, rows, genParams) {\r\n  const { minRoomSize, maxRoomSize, numRooms, maxRoomAttempts, roomTypeWeights } = genParams;\r\n  let roomAttempts = 0;\r\n\r\n  const weightedTypes = [];\r\n  let totalWeight = 0;\r\n  for (const type in roomTypeWeights) {\r\n    const weight = roomTypeWeights[type];\r\n    if (weight > 0) {\r\n      totalWeight += weight;\r\n      for (let i = 0; i < weight; i++) {\r\n        weightedTypes.push(type);\r\n      }\r\n    }\r\n  }\r\n  // Ensure weightedTypes is not empty if all weights are 0 (edge case)\r\n  if (weightedTypes.length === 0) {\r\n    weightedTypes.push('utility'); // Default fallback\r\n    console.warn(\r\n      \"[MapGen Rooms] No room type weights provided or all are zero. Defaulting to 'utility'.\"\r\n    );\r\n  }\r\n\r\n  while (rooms.length < numRooms && roomAttempts < maxRoomAttempts) {\r\n    roomAttempts++;\r\n    const roomWidth = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.randomInt)(minRoomSize, maxRoomSize);\r\n    const roomHeight = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.randomInt)(minRoomSize, maxRoomSize);\r\n    // Ensure room fits within map boundaries (leaving 1-tile border)\r\n    const roomCol = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.randomInt)(1, cols - roomWidth - 1);\r\n    const roomRow = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.randomInt)(1, rows - roomHeight - 1);\r\n\r\n    const roomType = weightedTypes[(0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.randomInt)(0, weightedTypes.length - 1)];\r\n\r\n    const newRoom = {\r\n      col: roomCol,\r\n      row: roomRow,\r\n      width: roomWidth,\r\n      height: roomHeight,\r\n      type: roomType,\r\n      id: `room_${rooms.length + 1}`,\r\n      centerTileX: Math.floor(roomCol + roomWidth / 2),\r\n      centerTileY: Math.floor(roomRow + roomHeight / 2),\r\n      connected: false,\r\n    };\r\n\r\n    let overlaps = false;\r\n    const buffer = 2; // Keep a buffer between rooms\r\n    for (const existingRoom of rooms) {\r\n      if (\r\n        newRoom.col < existingRoom.col + existingRoom.width + buffer &&\r\n        newRoom.col + newRoom.width + buffer > existingRoom.col &&\r\n        newRoom.row < existingRoom.row + existingRoom.height + buffer &&\r\n        newRoom.row + newRoom.height + buffer > existingRoom.row\r\n      ) {\r\n        overlaps = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!overlaps) {\r\n      rooms.push(newRoom);\r\n      // Carve room floor\r\n      for (let r = newRoom.row; r < newRoom.row + newRoom.height; r++) {\r\n        for (let c = newRoom.col; c < newRoom.col + newRoom.width; c++) {\r\n          // Double check bounds just in case calculation was off\r\n          if (r >= 0 && r < rows && c >= 0 && c < cols) {\r\n            map[r][c] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (rooms.length < numRooms) {\r\n    console.warn(\r\n      `[MapGen Rooms] Placed only ${rooms.length}/${numRooms} rooms after ${roomAttempts} attempts.`\r\n    );\r\n  } else {\r\n    console.log(`[MapGen Rooms] Placed ${rooms.length} rooms after ${roomAttempts} attempts.`);\r\n  }\r\n}\r\n\r\n// --- Helper: Connect Rooms ---\r\nfunction _connectRoomsBetter(map, rooms, cols, rows) {\r\n  if (rooms.length < 2) return;\r\n  console.log(`[MapGen Connect] Connecting ${rooms.length} rooms (improved)...`);\r\n\r\n  // Use a Set for faster checking of connected status\r\n  const connectedSet = new Set([rooms[0].id]);\r\n  let unconnectedRooms = rooms.slice(1); // Start with all but the first\r\n\r\n  while (unconnectedRooms.length > 0) {\r\n    let bestDistanceSq = Infinity;\r\n    let bestUnconnectedRoom = null;\r\n    let bestConnectedRoomId = null; // Store ID of the connected room\r\n    let bestUnconnectedIndex = -1;\r\n\r\n    // Find the unconnected room closest to ANY connected room\r\n    for (let i = 0; i < unconnectedRooms.length; i++) {\r\n      const roomU = unconnectedRooms[i];\r\n      for (const roomC of rooms) {\r\n        // Iterate through ALL rooms\r\n        if (connectedSet.has(roomC.id)) {\r\n          // Check if roomC is connected\r\n          const dx = roomU.centerTileX - roomC.centerTileX;\r\n          const dy = roomU.centerTileY - roomC.centerTileY;\r\n          const distSq = dx * dx + dy * dy;\r\n          if (distSq < bestDistanceSq) {\r\n            bestDistanceSq = distSq;\r\n            bestUnconnectedRoom = roomU;\r\n            bestConnectedRoomId = roomC.id;\r\n            bestUnconnectedIndex = i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (bestUnconnectedRoom && bestConnectedRoomId !== null) {\r\n      // Find the actual connected room object using the ID\r\n      const bestConnectedRoom = rooms.find((r) => r.id === bestConnectedRoomId);\r\n      if (!bestConnectedRoom) {\r\n        console.error(\r\n          `[MapGen Connect] Error: Could not find connected room with ID ${bestConnectedRoomId}. Skipping connection.`\r\n        );\r\n        // Remove the problematic unconnected room to avoid infinite loop\r\n        unconnectedRooms.splice(bestUnconnectedIndex, 1);\r\n        continue;\r\n      }\r\n\r\n      _carveCorridorBetween(map, bestConnectedRoom, bestUnconnectedRoom, cols, rows);\r\n      connectedSet.add(bestUnconnectedRoom.id); // Add the newly connected room ID to the set\r\n      unconnectedRooms.splice(bestUnconnectedIndex, 1); // Remove from unconnected list\r\n    } else {\r\n      console.error(\r\n        '[MapGen Connect] Could not find next pair of rooms to connect. Breaking loop. Remaining unconnected:',\r\n        unconnectedRooms.map((r) => r.id)\r\n      );\r\n      break; // Avoid infinite loop if something went wrong\r\n    }\r\n  }\r\n  console.log(`[MapGen Connect] Finished connecting rooms. Connected count: ${connectedSet.size}`);\r\n}\r\n\r\n// --- Helper: Carve Corridors ---\r\nfunction _carveCorridorBetween(map, roomA, roomB, cols, rows) {\r\n  const { centerTileX: ax, centerTileY: ay } = roomA;\r\n  const { centerTileX: bx, centerTileY: by } = roomB;\r\n  // Randomly choose L-shape direction (Horizontal then Vertical, or Vertical then Horizontal)\r\n  if (Math.random() < 0.5) {\r\n    // H then V\r\n    _carveHorizontalCorridor(map, ay, ax, bx, cols, rows);\r\n    _carveVerticalCorridor(map, bx, ay, by, cols, rows);\r\n  } else {\r\n    // V then H\r\n    _carveVerticalCorridor(map, ax, ay, by, cols, rows);\r\n    _carveHorizontalCorridor(map, by, ax, bx, cols, rows);\r\n  }\r\n}\r\nfunction _carveHorizontalCorridor(map, r, c1, c2, cols, rows) {\r\n  // Ensure row is valid\r\n  if (r < 0 || r >= rows) return;\r\n  const startCol = Math.max(0, Math.min(c1, c2)); // Clamp to map bounds\r\n  const endCol = Math.min(cols - 1, Math.max(c1, c2)); // Clamp to map bounds\r\n  for (let c = startCol; c <= endCol; c++) {\r\n    // Only carve if it's currently a wall\r\n    if (map[r]?.[c] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n      map[r][c] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR;\r\n    }\r\n    // Optional: Also carve adjacent vertical tiles for thickness > 1\r\n    // if (thickness > 1 && r+1 < rows && map[r+1]?.[c] === TILE_WALL) map[r+1][c] = TILE_CORRIDOR;\r\n  }\r\n}\r\nfunction _carveVerticalCorridor(map, c, r1, r2, cols, rows) {\r\n  // Ensure col is valid\r\n  if (c < 0 || c >= cols) return;\r\n  const startRow = Math.max(0, Math.min(r1, r2)); // Clamp to map bounds\r\n  const endRow = Math.min(rows - 1, Math.max(r1, r2)); // Clamp to map bounds\r\n  for (let r = startRow; r <= endRow; r++) {\r\n    // Only carve if it's currently a wall\r\n    if (map[r]?.[c] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n      map[r][c] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR;\r\n    }\r\n    // Optional: Also carve adjacent horizontal tiles for thickness > 1\r\n    // if (thickness > 1 && c+1 < cols && map[r]?.[c+1] === TILE_WALL) map[r][c+1] = TILE_CORRIDOR;\r\n  }\r\n}\r\n\r\n// --- Helper: Place Lift ---\r\n// Takes current `liftCoords` and returns the used/found coords and position\r\nfunction _placeLift(map, cols, rows, floorNumber, minFloor, tileSize, currentConsistentCoords) {\r\n  let coordsToUse = currentConsistentCoords;\r\n  let newlyFoundCoords = null;\r\n\r\n  // Find coords only on the first floor if not already set\r\n  if (floorNumber === minFloor && !coordsToUse) {\r\n    console.log(`[MapGen Floor ${floorNumber}] Finding initial lift placement location...`);\r\n    coordsToUse = _findLiftPlacementLocation(map, cols, rows);\r\n    if (!coordsToUse) {\r\n      // CRITICAL FALLBACK: If no suitable spot found, try placing near map center (even wall) and force connect\r\n      console.warn(\r\n        `[MapGen Floor ${floorNumber}] No ideal lift location found. Forcing placement near center.`\r\n      );\r\n      coordsToUse = { tileX: Math.floor(cols / 2), tileY: Math.floor(rows / 2) };\r\n    }\r\n    console.log(\r\n      `[MapGen Floor ${floorNumber}] Established consistent lift coords at tile(${coordsToUse.tileX}, ${coordsToUse.tileY})`\r\n    );\r\n    newlyFoundCoords = coordsToUse; // Mark that we found new coords\r\n  } else if (!coordsToUse && floorNumber > minFloor) {\r\n    // This should ideally not happen if generation proceeds floor by floor\r\n    throw new Error(`[MapGen Lift] Missing consistent coordinates for floor ${floorNumber}.`);\r\n  }\r\n\r\n  const { tileX, tileY } = coordsToUse;\r\n\r\n  // Basic bounds check for safety\r\n  if (tileY < 0 || tileY >= rows || tileX < 0 || tileX >= cols) {\r\n    throw new Error(\r\n      `[MapGen Lift] Coords (${tileX}, ${tileY}) are outside map bounds on floor ${floorNumber}.`\r\n    );\r\n  }\r\n\r\n  // Check if the chosen spot is a wall; if so, attempt connection\r\n  if (map[tileY][tileX] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n    console.warn(\r\n      `[MapGen Floor ${floorNumber}] Lift location tile(${tileX}, ${tileY}) is a wall. Forcing connection...`\r\n    );\r\n    const connected = _forceConnectionToPoint(map, tileX, tileY, cols, rows);\r\n    if (!connected) {\r\n      console.error(\r\n        `[MapGen Lift Connect] FAILED to connect wall at lift location tile(${tileX}, ${tileY}). Lift might be isolated.`\r\n      );\r\n      // We still place the lift, but the reachability check later should fail.\r\n    } else {\r\n      console.log(`  [MapGen Lift Connect] Connection attempt finished for wall at lift location.`);\r\n      // Ensure the tile itself is marked as corridor *before* setting to LIFT\r\n      if (map[tileY][tileX] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n        console.warn(\r\n          `  [MapGen Lift Connect] Force connection completed, but target tile (${tileX},${tileY}) remained WALL. Setting to CORRIDOR.`\r\n        );\r\n        map[tileY][tileX] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR; // Manually ensure it's walkable before becoming lift\r\n      }\r\n    }\r\n  } else {\r\n    console.log(\r\n      `  [MapGen Lift] Lift location tile(${tileX}, ${tileY}) is already walkable (Type: ${map[tileY][tileX]}).`\r\n    );\r\n  }\r\n\r\n  // Place the lift tile\r\n  map[tileY][tileX] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT;\r\n\r\n  // Calculate world position using the provided tileSize\r\n  const liftWorldPos = {\r\n    x: (tileX + 0.5) * tileSize,\r\n    y: (tileY + 0.5) * tileSize,\r\n    tileX: tileX,\r\n    tileY: tileY,\r\n  };\r\n\r\n  console.log(\r\n    `[MapGen Floor ${floorNumber}] Placed/Confirmed lift at tile(${tileX}, ${tileY}). World: (${liftWorldPos.x.toFixed(\r\n      1\r\n    )}, ${liftWorldPos.y.toFixed(1)})`\r\n  );\r\n\r\n  return { position: liftWorldPos, coords: newlyFoundCoords || coordsToUse }; // Return position and the definitive coords used/found\r\n}\r\n\r\n// --- Helper: Find Lift Location (For First Floor) ---\r\nfunction _findLiftPlacementLocation(map, cols, rows) {\r\n  const centerX = Math.floor(cols / 2),\r\n    centerY = Math.floor(rows / 2);\r\n  let bestSpot = null;\r\n  let minDistanceSq = Infinity;\r\n  const maxSearchRadius = Math.max(centerX, centerY); // Search outwards from center\r\n\r\n  console.log(`  [MapGen FindLift] Searching for lift spot, max radius ${maxSearchRadius}...`);\r\n\r\n  for (let radius = 0; radius <= maxSearchRadius; radius++) {\r\n    for (let dy = -radius; dy <= radius; dy++) {\r\n      for (let dx = -radius; dx <= radius; dx++) {\r\n        // Only check the boundary of the current radius ring\r\n        if (radius > 0 && Math.abs(dx) < radius && Math.abs(dy) < radius) continue;\r\n\r\n        const checkX = centerX + dx;\r\n        const checkY = centerY + dy;\r\n\r\n        // Check if inside map bounds (excluding outer border)\r\n        if (checkY >= 1 && checkY < rows - 1 && checkX >= 1 && checkX < cols - 1) {\r\n          const tile = map[checkY][checkX];\r\n\r\n          // Prefer placing on existing Corridor or Room Floor tiles\r\n          if (tile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR || tile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR) {\r\n            // Check for at least one walkable (non-wall) neighbor to ensure it's not isolated\r\n            let isConnected = false;\r\n            const directions = [\r\n              [0, -1],\r\n              [0, 1],\r\n              [-1, 0],\r\n              [1, 0],\r\n            ];\r\n            for (const [ddx, ddy] of directions) {\r\n              const nx = checkX + ddx;\r\n              const ny = checkY + ddy;\r\n              // Check neighbor bounds and type (Corridor, Floor, or *existing* Lift if somehow present)\r\n              const neighborTile = map[ny]?.[nx];\r\n              if (\r\n                neighborTile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR ||\r\n                neighborTile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR ||\r\n                neighborTile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT\r\n              ) {\r\n                isConnected = true;\r\n                break;\r\n              }\r\n            }\r\n\r\n            if (isConnected) {\r\n              const distSq = dx * dx + dy * dy; // Distance from center\r\n              // Found a suitable spot, check if it's closer than previous best\r\n              if (distSq < minDistanceSq) {\r\n                minDistanceSq = distSq;\r\n                bestSpot = { tileX: checkX, tileY: checkY };\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } // end dx loop\r\n    } // end dy loop\r\n\r\n    // If we found a best spot in this radius ring, use it and stop searching\r\n    if (bestSpot) {\r\n      console.log(\r\n        `  [MapGen FindLift] Selected best spot at tile(${bestSpot.tileX}, ${bestSpot.tileY}) radius ${radius}.`\r\n      );\r\n      return bestSpot;\r\n    }\r\n  } // end radius loop\r\n\r\n  console.warn('[MapGen FindLift] No suitable CORRIDOR or ROOM_FLOOR location found near center.');\r\n  // If no ideal spot, return null (the caller might force placement)\r\n  return null;\r\n}\r\n\r\n// --- Helper: Force Connection ---\r\nfunction _forceConnectionToPoint(map, targetX, targetY, cols, rows) {\r\n  console.log(\r\n    `  [MapGen Connect] Trying to connect wall at tile(${targetX}, ${targetY}) to walkable area...`\r\n  );\r\n  const directions = [\r\n    [0, -1],\r\n    [0, 1],\r\n    [-1, 0],\r\n    [1, 0],\r\n  ];\r\n  let isAdjacentToWalkable = false;\r\n  let adjacentWalkableCoord = null;\r\n\r\n  // 1. Check if already adjacent to a walkable tile\r\n  for (const [dx, dy] of directions) {\r\n    const nx = targetX + dx;\r\n    const ny = targetY + dy;\r\n    const neighborTile = map[ny]?.[nx];\r\n    if (\r\n      neighborTile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR ||\r\n      neighborTile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR ||\r\n      neighborTile === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT\r\n    ) {\r\n      isAdjacentToWalkable = true;\r\n      adjacentWalkableCoord = { x: nx, y: ny };\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (isAdjacentToWalkable) {\r\n    console.log(\r\n      `  [MapGen Connect] Target(${targetX}, ${targetY}) is adjacent to walkable at (${adjacentWalkableCoord.x}, ${adjacentWalkableCoord.y}). Setting target to Corridor.`\r\n    );\r\n    // Make the target tile itself walkable (Corridor is a safe bet)\r\n    map[targetY][targetX] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR;\r\n    return true; // Connection is trivial\r\n  }\r\n\r\n  // 2. If not adjacent, find the nearest walkable tile (Corridor or Floor) using BFS\r\n  console.log(\r\n    `  [MapGen Connect] Target not adjacent. Searching nearest walkable (Corridor/Floor) via BFS...`\r\n  );\r\n  const queue = [[targetX, targetY, 0]]; // x, y, distance\r\n  const visited = new Set([`${targetX},${targetY}`]);\r\n  const bfsPathable = [_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT]; // Can path through anything\r\n  const targetWalkable = [_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR];\r\n  let closestWalkable = null;\r\n  let minFoundDist = Infinity;\r\n\r\n  while (queue.length > 0) {\r\n    const [currX, currY, dist] = queue.shift();\r\n\r\n    // If we already found *a* walkable tile, don't explore paths longer than that\r\n    if (dist >= minFoundDist) continue;\r\n\r\n    for (const [dx, dy] of directions) {\r\n      const nextX = currX + dx;\r\n      const nextY = currY + dy;\r\n      const key = `${nextX},${nextY}`;\r\n\r\n      if (nextX >= 0 && nextX < cols && nextY >= 0 && nextY < rows && !visited.has(key)) {\r\n        const tileValue = map[nextY]?.[nextX];\r\n        visited.add(key);\r\n\r\n        // Found a target walkable tile?\r\n        if (targetWalkable.includes(tileValue)) {\r\n          if (dist + 1 < minFoundDist) {\r\n            // Found a closer one\r\n            minFoundDist = dist + 1;\r\n            closestWalkable = { x: nextX, y: nextY, dist: minFoundDist };\r\n            console.log(\r\n              `    [BFS] Found potential target at (${nextX}, ${nextY}), dist ${minFoundDist}`\r\n            );\r\n          }\r\n          // Don't push this target onto queue, we stop searching from here\r\n        } else if (bfsPathable.includes(tileValue)) {\r\n          // Can continue searching from this neighbor if it's pathable and closer than current best\r\n          if (dist + 1 < minFoundDist) {\r\n            queue.push([nextX, nextY, dist + 1]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 3. Carve path if a walkable tile was found\r\n  if (closestWalkable) {\r\n    console.log(\r\n      `  [MapGen Connect] Found closest walkable at tile(${closestWalkable.x}, ${closestWalkable.y}) distance ${closestWalkable.dist}. Carving path...`\r\n    );\r\n    // Simple L-shaped carving from target to closest walkable\r\n    _carveHorizontalCorridor(map, targetY, targetX, closestWalkable.x, cols, rows);\r\n    _carveVerticalCorridor(map, closestWalkable.x, targetY, closestWalkable.y, cols, rows);\r\n    console.log(`  [MapGen Connect] Carved path attempt finished.`);\r\n\r\n    // Verify the target tile itself became walkable (should be corridor now)\r\n    if (map[targetY][targetX] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR || map[targetY][targetX] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR) {\r\n      console.log(\r\n        `    [Verify] Target tile (${targetX},${targetY}) is now walkable (Type: ${map[targetY][targetX]})`\r\n      );\r\n      return true;\r\n    } else {\r\n      console.warn(\r\n        `  [MapGen Connect] Carving done, but target tile(${targetX}, ${targetY}) is still WALL (Value: ${map[targetY][targetX]}). Setting manually.`\r\n      );\r\n      // Force it just in case carving logic had an edge case\r\n      map[targetY][targetX] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR;\r\n      return true; // Assume success if we found a path and forced the tile\r\n    }\r\n  } else {\r\n    console.error(\r\n      `  [MapGen Connect] FAILED to find ANY nearby walkable (Corridor/Floor) via BFS from wall at tile(${targetX}, ${targetY}). Cannot connect.`\r\n    );\r\n    return false; // Connection failed\r\n  }\r\n}\r\n\r\n// --- Helper: Check Lift Reachability ---\r\nfunction _isLiftReachable(map, liftPosition, cols, rows) {\r\n  if (!liftPosition) return false;\r\n  const { tileX, tileY } = liftPosition;\r\n  if (\r\n    tileY < 0 ||\r\n    tileY >= rows ||\r\n    tileX < 0 ||\r\n    tileX >= cols ||\r\n    map[tileY]?.[tileX] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT\r\n  ) {\r\n    console.error(\r\n      `[MapValidation Reachability] Invalid lift position provided: (${tileX}, ${tileY})`\r\n    );\r\n    return false;\r\n  }\r\n\r\n  // Use BFS utility function to check reachability from the lift tile\r\n  // We need to know if the lift can reach *any* TILE_CORRIDOR or TILE_ROOM_FLOOR\r\n  const walkableForLiftSearch = [_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT]; // BFS can traverse these\r\n  const targetTiles = [_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR]; // Success if BFS finds one of these\r\n\r\n  const { reachable } = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.performBFS)(\r\n    map,\r\n    tileX,\r\n    tileY,\r\n    cols,\r\n    rows,\r\n    walkableForLiftSearch,\r\n    targetTiles\r\n  );\r\n\r\n  if (!reachable) {\r\n    console.error(\r\n      `[MapValidation Reachability] FAILED. Lift at tile(${tileX}, ${tileY}) is isolated from corridors/rooms.`\r\n    );\r\n  }\r\n  return reachable;\r\n}\r\n\r\n// --- Helper: Ensure Borders ---\r\nfunction _ensureMapBorders(map, cols, rows) {\r\n  console.log('  [MapGen] Ensuring map borders are walls.');\r\n  // Top and Bottom borders\r\n  for (let c = 0; c < cols; c++) {\r\n    if (map[0]?.[c] !== undefined) map[0][c] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL;\r\n    if (map[rows - 1]?.[c] !== undefined) map[rows - 1][c] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL;\r\n  }\r\n  // Left and Right borders\r\n  for (let r = 0; r < rows; r++) {\r\n    if (map[r]?.[0] !== undefined) map[r][0] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL;\r\n    if (map[r]?.[cols - 1] !== undefined) map[r][cols - 1] = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL;\r\n  }\r\n}\r\n\r\n// --- Debug Helper ---\r\n// (Optional, uncomment the call in generateLevelData to use when debugging reachability)\r\nfunction logMapGridForDebug(map, cols, rows) {\r\n  console.log('--- DEBUG MAP GRID ---');\r\n  for (let y = 0; y < rows; y++) {\r\n    const rowString = map[y]\r\n      .map((tile) => {\r\n        switch (tile) {\r\n          case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL:\r\n            return '#';\r\n          case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR:\r\n            return '.';\r\n          case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR:\r\n            return ' ';\r\n          case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT:\r\n            return 'L';\r\n          default:\r\n            return '?';\r\n        }\r\n      })\r\n      .join('');\r\n    console.log(rowString);\r\n  }\r\n  console.log('--- END DEBUG MAP GRID ---');\r\n}\r\n\n\n//# sourceURL=webpack://projectjs/./js/map/MapGen.js?");

/***/ }),

/***/ "./js/map/MapRenderer.js":
/*!*******************************!*\
  !*** ./js/map/MapRenderer.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapRenderer: () => (/* binding */ MapRenderer)\n/* harmony export */ });\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/constants.js */ \"./js/utils/constants.js\");\n/* harmony import */ var _utils_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/map.js */ \"./js/utils/map.js\");\n// src/map/mapRenderer.js\r\n\r\n\r\n // Załóżmy, że istnieje simpleHash\r\n\r\nclass MapRenderer {\r\n  constructor(tileSize) {\r\n    this.tileSize = tileSize;\r\n    this.tileColors = {}; // Cache dla spójnych kolorów kafelków na instancję mapy\r\n    this.baseWallColor = '#4a4a4a'; // Podstawowy kolor ścian\r\n    this.baseCorridorColor = '#a0a0a0'; // Podstawowy kolor korytarzy\r\n    this.baseRoomFloorColor = '#c0c0c0'; // Podstawowy kolor podłogi pokoju\r\n  }\r\n\r\n  // Zresetuj cache kolorów, gdy rysowana jest nowa mapa (wywoływane przez ProceduralMap)\r\n  resetColorCache() {\r\n    this.tileColors = {};\r\n  }\r\n\r\n  /** Pobierz lub wygeneruj kolor dla określonego kafelka */\r\n  getTileColor(r, c, tileValue, rooms) {\r\n    const key = `${r},${c}`;\r\n    if (this.tileColors[key]) {\r\n      return this.tileColors[key];\r\n    }\r\n\r\n    let color;\r\n    let brightnessFactor = 1.0;\r\n    // Używamy prostego hasha z koordynatów dla deterministycznej wariacji\r\n    const hash = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(r * 1000 + c); // Prosta funkcja hashująca oparta na koordynatach\r\n    const variation = ((hash % 21) - 10) / 100; // Wariacja od -0.1 do +0.1\r\n\r\n    switch (tileValue) {\r\n      case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL:\r\n        // Kolor bazowy + deterministyczna wariacja\r\n        brightnessFactor = 0.9 + variation * 0.5; // Mniejsza wariacja dla ścian\r\n        color = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)(this.baseWallColor, brightnessFactor);\r\n        break;\r\n      case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR:\r\n        // Kolor bazowy + deterministyczna wariacja\r\n        brightnessFactor = 0.95 + variation;\r\n        color = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)(this.baseCorridorColor, brightnessFactor);\r\n        break;\r\n      case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR:\r\n        // Kolor bazowy podłogi pokoju (zostanie nadpisany w drawRoomDetails)\r\n        color = this.baseRoomFloorColor;\r\n        break;\r\n      case _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_LIFT:\r\n        // Kolor windy - można zrobić ciekawszy\r\n        color = '#707080'; // Trochę jaśniejszy\r\n        break;\r\n      default:\r\n        color = '#ff00ff'; // Kolor błędu\r\n        break;\r\n    }\r\n    this.tileColors[key] = color;\r\n    return color;\r\n  }\r\n\r\n  /** Główna funkcja rysująca */\r\n  draw(ctx, mapData, bookImage = null) {\r\n    const { map, rooms, books, liftPosition, offsetX, offsetY, cols, rows } = mapData;\r\n\r\n    // Zaokrąglij przesunięcia dla ostrości\r\n    const currentOffsetX = Math.floor(offsetX);\r\n    const currentOffsetY = Math.floor(offsetY);\r\n\r\n    // Określ widoczne kafelki z małym zapasem\r\n    const startCol = Math.max(0, Math.floor(-currentOffsetX / this.tileSize) - 1);\r\n    const endCol = Math.min(\r\n      cols,\r\n      Math.ceil((-currentOffsetX + ctx.canvas.width) / this.tileSize) + 1\r\n    );\r\n    const startRow = Math.max(0, Math.floor(-currentOffsetY / this.tileSize) - 1);\r\n    const endRow = Math.min(\r\n      rows,\r\n      Math.ceil((-currentOffsetY + ctx.canvas.height) / this.tileSize) + 1\r\n    );\r\n\r\n    ctx.save(); // Zapisz stan kontekstu\r\n    // Wyłącz wygładzanie dla pixel-artu (jeśli potrzebne)\r\n    // ctx.imageSmoothingEnabled = false; // Już w GameRenderer\r\n\r\n    // 1. Narysuj podstawowe kafelki (ściany, korytarze, domyślna podłoga, baza windy)\r\n    this.drawBaseTiles(\r\n      ctx,\r\n      map,\r\n      rooms, // Przekazujemy rooms do getTileColor, jeśli będzie potrzebne\r\n      currentOffsetX,\r\n      currentOffsetY,\r\n      cols,\r\n      rows,\r\n      startRow,\r\n      endRow,\r\n      startCol,\r\n      endCol\r\n    );\r\n\r\n    // 2. Narysuj specyficzne podłogi i dekoracje pokoi\r\n    this.drawRoomDetails(\r\n      ctx,\r\n      map,\r\n      rooms,\r\n      liftPosition, // Przekazujemy pozycję windy do sprawdzenia\r\n      currentOffsetX,\r\n      currentOffsetY,\r\n      cols,\r\n      rows,\r\n      startRow,\r\n      endRow,\r\n      startCol,\r\n      endCol\r\n    );\r\n\r\n    // 3. Narysuj detale windy (nad podłogami pokoi, jeśli konieczne)\r\n    this.drawLiftDetails(ctx, liftPosition, currentOffsetX, currentOffsetY);\r\n\r\n    // 4. Narysuj książki\r\n    this.drawBooks(ctx, books, currentOffsetX, currentOffsetY, bookImage);\r\n\r\n    ctx.restore(); // Przywróć stan kontekstu\r\n  }\r\n\r\n  /** Narysuj podstawowe kafelki */\r\n  drawBaseTiles(ctx, map, rooms, offsetX, offsetY, cols, rows, startRow, endRow, startCol, endCol) {\r\n    ctx.save();\r\n    // Usunąłem domyślny cień, będziemy dodawać tam, gdzie trzeba\r\n    ctx.shadowColor = 'transparent';\r\n\r\n    const wallEdgeColorDark = '#383838'; // Ciemniejszy dla cienia/dołu\r\n    const wallEdgeColorLight = '#606060'; // Jaśniejszy dla góry/oświetlenia\r\n    const wallTopEdgeColor = '#757575'; // Najjaśniejszy góra\r\n\r\n    for (let r = startRow; r < endRow; r++) {\r\n      for (let c = startCol; c < endCol; c++) {\r\n        const tileValue = map[r]?.[c];\r\n        if (tileValue === undefined) continue;\r\n\r\n        // Zaokrąglij współrzędne rysowania do liczb całkowitych!\r\n        const screenX = Math.floor(c * this.tileSize + offsetX);\r\n        const screenY = Math.floor(r * this.tileSize + offsetY);\r\n        const color = this.getTileColor(r, c, tileValue, rooms);\r\n\r\n        ctx.fillStyle = color;\r\n        ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);\r\n\r\n        // --- Ulepszone rysowanie ścian i krawędzi ---\r\n        if (tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n          // Prosta tekstura szumu dla ściany\r\n          ctx.fillStyle = 'rgba(0,0,0,0.06)'; // Półprzezroczysty czarny\r\n          for (let i = 0; i < 5; i++) {\r\n            // Kilka punktów szumu\r\n            ctx.fillRect(\r\n              screenX + Math.random() * this.tileSize,\r\n              screenY + Math.random() * this.tileSize,\r\n              1,\r\n              1\r\n            );\r\n          }\r\n\r\n          // Rysujemy krawędzie tylko jeśli sąsiad NIE jest ścianą\r\n          const edgeSize = 2; // Grubość krawędzi\r\n\r\n          // Górna krawędź (najjaśniejsza)\r\n          if (r > 0 && map[r - 1]?.[c] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n            ctx.fillStyle = wallTopEdgeColor;\r\n            ctx.fillRect(screenX, screenY, this.tileSize, edgeSize);\r\n          }\r\n          // Dolna krawędź (ciemna)\r\n          if (r < rows - 1 && map[r + 1]?.[c] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n            ctx.fillStyle = wallEdgeColorDark;\r\n            ctx.fillRect(screenX, screenY + this.tileSize - edgeSize, this.tileSize, edgeSize);\r\n          }\r\n          // Lewa krawędź (jasna)\r\n          if (c > 0 && map[r]?.[c - 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n            ctx.fillStyle = wallEdgeColorLight;\r\n            ctx.fillRect(screenX, screenY + edgeSize, edgeSize, this.tileSize - edgeSize); // Zaczynamy poniżej górnej krawędzi\r\n          }\r\n          // Prawa krawędź (ciemna)\r\n          if (c < cols - 1 && map[r]?.[c + 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL) {\r\n            ctx.fillStyle = wallEdgeColorDark;\r\n            ctx.fillRect(\r\n              screenX + this.tileSize - edgeSize,\r\n              screenY + edgeSize,\r\n              edgeSize,\r\n              this.tileSize - edgeSize\r\n            ); // Zaczynamy poniżej górnej krawędzi\r\n          }\r\n\r\n          // Narożniki (opcjonalnie, dla wygładzenia)\r\n          // Wewnętrzny górny lewy róg\r\n          if (\r\n            r > 0 &&\r\n            c > 0 &&\r\n            map[r - 1]?.[c] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL &&\r\n            map[r]?.[c - 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL &&\r\n            map[r - 1]?.[c - 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL\r\n          ) {\r\n            ctx.fillStyle = wallEdgeColorLight; // Kompromisowy kolor\r\n            ctx.fillRect(screenX, screenY, edgeSize, edgeSize);\r\n          }\r\n          // Wewnętrzny górny prawy róg\r\n          if (\r\n            r > 0 &&\r\n            c < cols - 1 &&\r\n            map[r - 1]?.[c] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL &&\r\n            map[r]?.[c + 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL &&\r\n            map[r - 1]?.[c + 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_WALL\r\n          ) {\r\n            ctx.fillStyle = wallTopEdgeColor; // Jasny bo z góry\r\n            ctx.fillRect(screenX + this.tileSize - edgeSize, screenY, edgeSize, edgeSize);\r\n          }\r\n          // itd. dla dolnych rogów...\r\n        } else if (tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR) {\r\n          // Bardzo lekka tekstura dla korytarza\r\n          ctx.fillStyle = 'rgba(255,255,255,0.03)'; // Ledwo widoczny biały szum\r\n          for (let i = 0; i < 3; i++) {\r\n            ctx.fillRect(\r\n              screenX + Math.random() * this.tileSize,\r\n              screenY + Math.random() * this.tileSize,\r\n              1,\r\n              1\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n    ctx.restore();\r\n  }\r\n\r\n  /** Narysuj specyficzne podłogi i dekoracje pokoi */\r\n  drawRoomDetails(\r\n    ctx,\r\n    map,\r\n    rooms,\r\n    liftPosition, // Dodaliśmy liftPosition\r\n    offsetX,\r\n    offsetY,\r\n    cols,\r\n    rows,\r\n    startRow,\r\n    endRow,\r\n    startCol,\r\n    endCol\r\n  ) {\r\n    ctx.save();\r\n    ctx.shadowColor = 'transparent'; // Brak cieni dla detali pokoju\r\n\r\n    for (const room of rooms) {\r\n      // Podstawowe sprawdzenie widoczności dla ramki pokoju\r\n      if (\r\n        room.col + room.width < startCol ||\r\n        room.col > endCol ||\r\n        room.row + room.height < startRow ||\r\n        room.row > endRow\r\n      )\r\n        continue;\r\n\r\n      const roomScreenX = Math.floor(room.col * this.tileSize + offsetX);\r\n      const roomScreenY = Math.floor(room.row * this.tileSize + offsetY);\r\n      const roomScreenW = room.width * this.tileSize;\r\n      const roomScreenH = room.height * this.tileSize;\r\n\r\n      // --- Określenie Koloru Podłogi ---\r\n      // Użyjemy spójnego, ale zróżnicowanego koloru bazowego dla typu\r\n      let floorColor = this.baseRoomFloorColor; // Domyślny szary\r\n      let roomSeed = room.id + this.floorNumber * 100; // Prosty seed oparty na ID pokoju i piętrze\r\n\r\n      switch (room.type) {\r\n        case 'classroom':\r\n          floorColor = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)('#a0c8e0', 0.9 + ((0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(roomSeed) % 11) / 100);\r\n          break; // Niebieskawy\r\n        case 'office':\r\n          floorColor = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)('#f0e8c0', 0.9 + ((0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(roomSeed) % 11) / 100);\r\n          break; // Beżowy\r\n        case 'library':\r\n          floorColor = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)('#d8c0a8', 0.9 + ((0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(roomSeed) % 11) / 100);\r\n          break; // Drewniany\r\n        case 'gym':\r\n          floorColor = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)('#b0d0b0', 0.9 + ((0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(roomSeed) % 11) / 100);\r\n          break; // Zielonkawy\r\n        case 'lab':\r\n          floorColor = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)('#e0e0ff', 0.9 + ((0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(roomSeed) % 11) / 100);\r\n          break; // Jasny niebiesko-fioletowy\r\n        case 'storage':\r\n          floorColor = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)('#b0a090', 0.9 + ((0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(roomSeed) % 11) / 100);\r\n          break; // Szaro-brązowy\r\n        case 'utility':\r\n          floorColor = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)('#b0b0b0', 0.9 + ((0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(roomSeed) % 11) / 100);\r\n          break; // Szary beton\r\n      }\r\n\r\n      // --- Rysowanie Podłogi Pokoju (kafelek po kafelku w widocznym obszarze) ---\r\n      for (\r\n        let r = Math.max(room.row, startRow);\r\n        r < Math.min(room.row + room.height, endRow);\r\n        r++\r\n      ) {\r\n        for (\r\n          let c = Math.max(room.col, startCol);\r\n          c < Math.min(room.col + room.width, endCol);\r\n          c++\r\n        ) {\r\n          const tileValue = map[r]?.[c];\r\n          // --- FIX WINDY i MIGOTANIA ---\r\n          // Rysujemy podłogę TYLKO jeśli to TILE_ROOM_FLOOR\r\n          // (nie rysujemy na ścianach, korytarzach I WINDZIE)\r\n          if (tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR) {\r\n            const screenX = Math.floor(c * this.tileSize + offsetX);\r\n            const screenY = Math.floor(r * this.tileSize + offsetY);\r\n\r\n            // Deterministyczna wariacja jasności dla każdego kafelka podłogi\r\n            const tileHash = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(r * 5000 + c * 3 + room.id); // Hash z uwzględnieniem pokoju\r\n            const variation = ((tileHash % 11) - 5) / 100; // Wariacja -0.05 do +0.05\r\n            const brightnessFactor = 0.98 + variation;\r\n            ctx.fillStyle = (0,_utils_map_js__WEBPACK_IMPORTED_MODULE_1__.adjustColorBrightness)(floorColor, brightnessFactor);\r\n\r\n            ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);\r\n\r\n            // Opcjonalna dodatkowa tekstura podłogi (np. linie, wzór)\r\n            // if (room.type === 'gym' && (r + c) % 2 === 0) { // Prosty wzór szachownicy dla siłowni\r\n            //   ctx.fillStyle = 'rgba(0,0,0,0.05)';\r\n            //   ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);\r\n            // }\r\n            if (room.type === 'lab') {\r\n              // Linie siatki dla laboratorium\r\n              ctx.strokeStyle = 'rgba(0,0,0,0.08)';\r\n              ctx.lineWidth = 1;\r\n              ctx.strokeRect(screenX + 0.5, screenY + 0.5, this.tileSize - 1, this.tileSize - 1);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // --- Rysowanie Dekoracji (używając współrzędnych ekranu) ---\r\n      // Przekazujemy screenX, screenY, W, H pokoju\r\n      this.drawRoomDecorations(ctx, room, roomScreenX, roomScreenY, roomScreenW, roomScreenH);\r\n    }\r\n    ctx.restore();\r\n  }\r\n\r\n  /** Narysuj detale windy (przycisk, kontur) */\r\n  drawLiftDetails(ctx, liftPosition, offsetX, offsetY) {\r\n    if (!liftPosition) return;\r\n\r\n    const screenX = Math.floor(liftPosition.tileX * this.tileSize + offsetX);\r\n    const screenY = Math.floor(liftPosition.tileY * this.tileSize + offsetY);\r\n\r\n    // Sprawdź, czy winda jest widoczna przed rysowaniem detali\r\n    if (\r\n      screenX + this.tileSize < 0 ||\r\n      screenX > ctx.canvas.width ||\r\n      screenY + this.tileSize < 0 ||\r\n      screenY > ctx.canvas.height\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    ctx.save();\r\n    ctx.shadowColor = 'transparent'; // Brak cienia dla detali windy\r\n\r\n    // Wyraźniejsza ramka windy\r\n    ctx.strokeStyle = '#d0d0d0'; // Jasna ramka\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeRect(screenX + 0.5, screenY + 0.5, this.tileSize - 1, this.tileSize - 1);\r\n    ctx.strokeStyle = '#404040'; // Ciemny wewnętrzny cień\r\n    ctx.strokeRect(screenX + 1.5, screenY + 1.5, this.tileSize - 3, this.tileSize - 3);\r\n\r\n    // Ulepszony przycisk\r\n    const buttonRadius = this.tileSize * 0.15; // Trochę większy\r\n    const buttonX = screenX + this.tileSize * 0.8;\r\n    const buttonY = screenY + this.tileSize * 0.5;\r\n\r\n    // Podstawa przycisku (ciemniejsza)\r\n    ctx.fillStyle = '#444';\r\n    ctx.beginPath();\r\n    ctx.arc(buttonX, buttonY, buttonRadius, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    // Sam przycisk (czerwony)\r\n    ctx.fillStyle = '#ff4444';\r\n    ctx.beginPath();\r\n    ctx.arc(buttonX, buttonY, buttonRadius * 0.8, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    // Odblask na przycisku\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\r\n    ctx.beginPath();\r\n    ctx.arc(\r\n      buttonX - buttonRadius * 0.2,\r\n      buttonY - buttonRadius * 0.2,\r\n      buttonRadius * 0.3,\r\n      0,\r\n      Math.PI * 2\r\n    );\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /** Narysuj dekoracje dla konkretnego pokoju */\r\n  drawRoomDecorations(ctx, room, x, y, w, h) {\r\n    // x, y to lewy górny róg pokoju na ekranie\r\n    // w, h to szerokość i wysokość pokoju na ekranie\r\n    const ts = this.tileSize;\r\n    const margin = ts * 0.2; // Mniejszy margines\r\n    const objMargin = ts * 0.1; // Odstęp między obiektami\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#444'; // Ciemniejsza domyślna obwódka\r\n\r\n    // === FUNKCJE POMOCNICZE DO RYSOWANIA ===\r\n    const drawRect = (rx, ry, rw, rh, color, outline = true) => {\r\n      ctx.fillStyle = color;\r\n      const screenX = Math.floor(x + rx);\r\n      const screenY = Math.floor(y + ry);\r\n      const screenW = Math.floor(rw);\r\n      const screenH = Math.floor(rh);\r\n      ctx.fillRect(screenX, screenY, screenW, screenH);\r\n      if (outline) {\r\n        ctx.strokeRect(screenX + 0.5, screenY + 0.5, screenW - 1, screenH - 1);\r\n      }\r\n    };\r\n    const drawCircle = (cx, cy, radius, color, outline = true) => {\r\n      ctx.fillStyle = color;\r\n      const screenX = Math.floor(x + cx);\r\n      const screenY = Math.floor(y + cy);\r\n      ctx.beginPath();\r\n      ctx.arc(screenX, screenY, Math.floor(radius), 0, Math.PI * 2);\r\n      ctx.fill();\r\n      if (outline) {\r\n        ctx.stroke();\r\n      }\r\n    };\r\n    // =======================================\r\n\r\n    switch (room.type) {\r\n      case 'classroom': // Sala lekcyjna\r\n        ctx.strokeStyle = '#5d4037'; // Brązowa obwódka dla mebli\r\n        const deskW = ts * 0.6,\r\n          deskH = ts * 0.4,\r\n          chairH = ts * 0.25;\r\n        const spaceX = ts * 1.0,\r\n          spaceY = ts * 0.9;\r\n        // Tablica na górnej ścianie\r\n        drawRect(w * 0.25, margin, w * 0.5, ts * 0.2, '#333', true);\r\n        drawRect(w * 0.25 + 2, margin + 2, w * 0.5 - 4, ts * 0.2 - 4, '#4CAF50', false); // Zielona powierzchnia\r\n\r\n        // Ławki i krzesła w rzędach\r\n        for (let r = 0; ; r++) {\r\n          const rowY = margin + ts * 0.5 + r * spaceY;\r\n          if (rowY + deskH + chairH > h - margin) break; // Sprawdzenie czy zmieści się rząd\r\n          for (let c = 0; ; c++) {\r\n            const colX = margin + c * spaceX;\r\n            if (colX + deskW > w - margin) break; // Sprawdzenie czy zmieści się kolumna\r\n            // Ławka\r\n            drawRect(colX, rowY, deskW, deskH, '#8B4513');\r\n            // Krzesło poniżej\r\n            drawRect(colX + deskW * 0.1, rowY + deskH + objMargin, deskW * 0.8, chairH, '#6a4a3a');\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 'office': // Biuro\r\n        ctx.strokeStyle = '#5d4037';\r\n        // Biurko\r\n        const tableW = Math.min(w * 0.6, ts * 2.5);\r\n        const tableH = Math.min(h * 0.4, ts * 1.2);\r\n        drawRect(margin, margin, tableW, tableH, '#a0522d');\r\n        // Krzesło biurowe\r\n        drawRect(margin + tableW + objMargin, margin + tableH * 0.1, ts * 0.6, ts * 0.6, '#444');\r\n        // Szafa na akta\r\n        const cabinetW = ts * 0.8;\r\n        drawRect(w - margin - cabinetW, margin, cabinetW, h - margin * 2, '#6B4F41');\r\n        // Komputer na biurku (symbolicznie)\r\n        drawRect(margin + objMargin, margin + objMargin, ts * 0.5, ts * 0.4, '#333'); // Monitor\r\n        drawRect(\r\n          margin + objMargin + ts * 0.1,\r\n          margin + objMargin + ts * 0.4 + 2,\r\n          ts * 0.3,\r\n          ts * 0.1,\r\n          '#555'\r\n        ); // Klawiatura\r\n        break;\r\n\r\n      case 'library': // Biblioteka\r\n        ctx.strokeStyle = '#402a10'; // Ciemniejsza obwódka dla regałów\r\n        const shelfW = ts * 0.6;\r\n        const shelfSpacing = ts * 1.5;\r\n        // Regały w pionie\r\n        for (let sx = margin; sx < w - margin - shelfW; sx += shelfSpacing) {\r\n          drawRect(sx, margin, shelfW, h - margin * 2, '#654321');\r\n          // Linie półek\r\n          ctx.strokeStyle = 'rgba(0,0,0,0.3)';\r\n          for (let shelfY = margin + ts * 0.5; shelfY < h - margin; shelfY += ts * 0.7) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(x + sx, y + shelfY);\r\n            ctx.lineTo(x + sx + shelfW, y + shelfY);\r\n            ctx.stroke();\r\n          }\r\n          ctx.strokeStyle = '#402a10'; // Przywróć główny kolor obwódki\r\n        }\r\n        // Stół do czytania (jeśli jest miejsce)\r\n        if (w > shelfSpacing * 1.5) {\r\n          const tableLibX = shelfW + margin + (w - shelfW * 2 - margin * 2 - ts * 1.5) / 2; // Wyśrodkuj stół między regałami\r\n          if (tableLibX > shelfW + margin) {\r\n            // Upewnij się, że jest miejsce\r\n            drawRect(tableLibX, h * 0.3, ts * 1.5, h * 0.4, '#966F33');\r\n            // Krzesła przy stole\r\n            drawRect(tableLibX + ts * 0.2, h * 0.3 - ts * 0.3, ts * 0.5, ts * 0.25, '#6a4a3a');\r\n            drawRect(\r\n              tableLibX + ts * 0.2,\r\n              h * 0.3 + h * 0.4 + objMargin,\r\n              ts * 0.5,\r\n              ts * 0.25,\r\n              '#6a4a3a'\r\n            );\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 'gym': // Siłownia\r\n        ctx.strokeStyle = '#555';\r\n        // Maty do ćwiczeń\r\n        drawRect(margin, margin, w * 0.4, h * 0.3, '#778899');\r\n        drawRect(w - margin - w * 0.3, h - margin - h * 0.4, w * 0.3, h * 0.4, '#778899');\r\n        // Bieżnia (symbolicznie)\r\n        drawRect(w * 0.6, margin, ts * 0.8, ts * 1.8, '#333');\r\n        drawRect(w * 0.6 + ts * 0.1, margin + ts * 0.1, ts * 0.6, ts * 1.6, '#555', false);\r\n        // Ławeczka\r\n        drawRect(margin, h * 0.5, ts * 1.5, ts * 0.4, '#8B4513');\r\n        // Stojak z ciężarkami\r\n        drawRect(w - margin - ts * 0.5, margin, ts * 0.5, ts * 1.5, '#444');\r\n        drawCircle(w - margin - ts * 0.25, margin + ts * 0.3, ts * 0.15, '#666');\r\n        drawCircle(w - margin - ts * 0.25, margin + ts * 0.7, ts * 0.15, '#666');\r\n        drawCircle(w - margin - ts * 0.25, margin + ts * 1.1, ts * 0.15, '#666');\r\n        break;\r\n\r\n      case 'lab': // Laboratorium\r\n        ctx.strokeStyle = '#668';\r\n        // Stoły laboratoryjne (długie)\r\n        const labTableH = ts * 0.8;\r\n        drawRect(margin, margin, w - margin * 2, labTableH, '#d0d0d8'); // Jasnoszary stół\r\n        drawRect(margin, h - margin - labTableH, w - margin * 2, labTableH, '#d0d0d8');\r\n        // Sprzęt na stołach\r\n        drawRect(margin + ts * 0.2, margin + ts * 0.1, ts * 0.5, ts * 0.5, '#4a90e2'); // Coś niebieskiego\r\n        drawRect(margin + ts * 1.0, margin + ts * 0.1, ts * 0.3, ts * 0.6, '#f5a623'); // Coś pomarańczowego\r\n        drawCircle(w - margin * 2 - ts * 0.4, margin + labTableH * 0.5, ts * 0.2, '#e04040', true); // Coś czerwonego okrągłego\r\n        // Szafka z odczynnikami\r\n        drawRect(\r\n          w * 0.4,\r\n          margin + labTableH + objMargin,\r\n          ts,\r\n          h - margin * 2 - labTableH * 2 - objMargin * 2,\r\n          '#a0a0b0'\r\n        );\r\n        break;\r\n\r\n      case 'storage': // Magazyn\r\n        ctx.strokeStyle = '#4d4030';\r\n        // Półki/regały metalowe\r\n        const metalShelfW = w - margin * 2;\r\n        const metalShelfH = ts * 0.5;\r\n        drawRect(margin, margin, metalShelfW, metalShelfH, '#9e9e9e');\r\n        drawRect(margin, h - margin - metalShelfH, metalShelfW, metalShelfH, '#9e9e9e');\r\n        // Pudła\r\n        const boxSize = ts * 0.6;\r\n        drawRect(margin + ts * 0.2, margin + metalShelfH + objMargin, boxSize, boxSize, '#bf8f6f');\r\n        drawRect(margin + ts * 1.0, margin + metalShelfH + objMargin, boxSize, boxSize, '#bf8f6f');\r\n        drawRect(\r\n          w - margin - boxSize * 1.5,\r\n          margin + metalShelfH + objMargin * 3,\r\n          boxSize * 1.2,\r\n          boxSize * 0.8,\r\n          '#bf8f6f'\r\n        );\r\n        // Stare biurko w rogu\r\n        drawRect(w - margin - ts, h - margin - ts, ts * 0.8, ts * 0.8, '#6a4a3a');\r\n        break;\r\n\r\n      case 'utility': // Pomieszczenie gospodarcze\r\n      default: // Domyślne, jeśli typ nieznany\r\n        ctx.strokeStyle = '#5d4037';\r\n        // Skrzynki/urządzenia\r\n        drawRect(w * 0.1, h * 0.15, w * 0.3, h * 0.25, '#A0522D');\r\n        drawRect(w * 0.6, h * 0.5, w * 0.3, h * 0.4, '#A0522D');\r\n        // Szafa metalowa\r\n        drawRect(w - margin - ts * 0.5, margin, ts * 0.5, h - margin * 2, '#777');\r\n        // Rury/kable (symbolicznie)\r\n        ctx.strokeStyle = '#555';\r\n        ctx.lineWidth = 3;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + margin, y + h * 0.8);\r\n        ctx.lineTo(x + w - margin, y + h * 0.8);\r\n        ctx.stroke();\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + w * 0.7, y + margin);\r\n        ctx.lineTo(x + w * 0.7, y + h - margin);\r\n        ctx.stroke();\r\n        ctx.lineWidth = 1; // Przywróć grubość linii\r\n        break;\r\n    }\r\n  }\r\n\r\n  /** Narysuj książki */\r\n  drawBooks(ctx, books, offsetX, offsetY, bookImage) {\r\n    if (!books || books.length === 0) return;\r\n    const defaultBookSize = this.tileSize * 0.6;\r\n\r\n    for (const book of books) {\r\n      const isCollected = book.isCollected || book.collected; // Obsłuż obie potencjalne właściwości\r\n      if (!isCollected) {\r\n        const bookSize = book.size || defaultBookSize;\r\n        // Zaokrąglij współrzędne rysowania\r\n        const screenX = Math.floor(book.x + offsetX - bookSize / 2);\r\n        const screenY = Math.floor(book.y + offsetY - bookSize / 2);\r\n\r\n        // Podstawowe sprawdzenie widoczności\r\n        if (\r\n          screenX + bookSize > 0 &&\r\n          screenX < ctx.canvas.width &&\r\n          screenY + bookSize > 0 &&\r\n          screenY < ctx.canvas.height\r\n        ) {\r\n          // Preferuj własną metodę rysowania książki, jeśli dostępna\r\n          if (typeof book.draw === 'function') {\r\n            // Przekazujemy zaokrąglone współrzędne i rozmiar\r\n            book.draw(ctx, offsetX, offsetY, bookImage); // book.draw sama powinna zaokrąglać\r\n          } else {\r\n            // Rysowanie zapasowe\r\n            if (bookImage) {\r\n              // Rysujemy z zaokrąglonymi współrzędnymi\r\n              ctx.drawImage(bookImage, screenX, screenY, bookSize, bookSize);\r\n            } else {\r\n              ctx.fillStyle = '#8d6e63'; // Brązowy kolor książki\r\n              ctx.fillRect(screenX, screenY, bookSize, bookSize);\r\n              ctx.strokeStyle = '#5d4037'; // Ciemniejszy kontur\r\n              ctx.lineWidth = 1;\r\n              ctx.strokeRect(screenX + 0.5, screenY + 0.5, bookSize - 1, bookSize - 1); // Rysujemy ramkę wyraźniej\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Koniec klasy MapRenderer\r\n\n\n//# sourceURL=webpack://projectjs/./js/map/MapRenderer.js?");

/***/ }),

/***/ "./js/map/ProceduralMap.js":
/*!*********************************!*\
  !*** ./js/map/ProceduralMap.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProceduralMap: () => (/* binding */ ProceduralMap)\n/* harmony export */ });\n/* harmony import */ var _Book_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Book.js */ \"./js/map/Book.js\");\n/* harmony import */ var _MapRenderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapRenderer.js */ \"./js/map/MapRenderer.js\");\n/* harmony import */ var _utils_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/map.js */ \"./js/utils/map.js\");\n/* harmony import */ var _MapGen_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MapGen.js */ \"./js/map/MapGen.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/constants.js */ \"./js/utils/constants.js\");\n// src/map/ProceduralMap.js\r\n\r\n\r\n\r\n // Upewnij się, że map.js eksportuje randomInt\r\n\r\n\r\n\r\n// Uwaga: consistentLiftCoords jest teraz zarządzane wewnętrznie przez mapGenerator.js\r\n\r\nclass ProceduralMap {\r\n  constructor(canvasWidth, canvasHeight, floorNumber, minFloor, maxFloor) {\r\n    this.tileSize = 32;\r\n    this.cols = 40;\r\n    this.rows = 30;\r\n    this.width = this.cols * this.tileSize;\r\n    this.height = this.rows * this.tileSize;\r\n    this.offsetX = 0;\r\n    this.offsetY = 0;\r\n\r\n    this.floorNumber = floorNumber;\r\n    this.minFloor = minFloor;\r\n    this.maxFloor = maxFloor;\r\n\r\n    // Stan mapy - inicjalizowany po wygenerowaniu\r\n    this.map = null;\r\n    this.rooms = [];\r\n    this.books = [];\r\n    this.liftPosition = null; // Pozycja windy {x, y, tileX, tileY}\r\n\r\n    // Moduły\r\n    this.renderer = new _MapRenderer_js__WEBPACK_IMPORTED_MODULE_1__.MapRenderer(this.tileSize);\r\n\r\n    // --- Generowanie ---\r\n    // Zdefiniuj parametry generowania tutaj lub przekaż je\r\n    const generationParams = {\r\n      minRoomSize: 5,\r\n      maxRoomSize: 10,\r\n      corridorThickness: 1,\r\n      numRooms: 12,\r\n      maxRoomAttempts: 200,\r\n      booksPerMap: 5, // Książki umieszczane *po* wygenerowaniu\r\n      roomTypeWeights: {\r\n        // Wagi typów pomieszczeń\r\n        classroom: 50,\r\n        office: 25,\r\n        library: 15,\r\n        lab: 10, // ! NOWY TYP: Laboratorium\r\n        storage: 5, // ! NOWY TYP: Magazyn\r\n        // szansa na siłownię (gym) jest obsługiwana przez generator na podstawie floorNumber\r\n        utility: 10, // Pomieszczenie gospodarcze\r\n      },\r\n    };\r\n\r\n    try {\r\n      // Konfiguracja dla generatora\r\n      const generationConfig = {\r\n        cols: this.cols,\r\n        rows: this.rows,\r\n        floorNumber: this.floorNumber,\r\n        minFloor: this.minFloor,\r\n        maxFloor: this.maxFloor, // Przekaż też maxFloor, może być przydatne później\r\n        tileSize: this.tileSize, // Przekaż tileSize, jeśli generator go potrzebuje (np. do pozycji windy w świecie)\r\n        generationParams: generationParams,\r\n      };\r\n\r\n      // Generuj dane układu mapy\r\n      const { map, rooms, liftPosition } = (0,_MapGen_js__WEBPACK_IMPORTED_MODULE_3__.generateLevelData)(generationConfig);\r\n\r\n      // Zapisz wygenerowane dane\r\n      this.map = map;\r\n      this.rooms = rooms;\r\n      this.liftPosition = liftPosition; // Zawiera już współrzędne świata, jeśli obliczone przez generator\r\n\r\n      // --- Kroki po generacji ---\r\n      this.renderer.resetColorCache(); // Zresetuj cache renderera dla nowej mapy\r\n      this.placeBooksReliably(generationParams.booksPerMap); // Umieść książki na wygenerowanej mapie\r\n\r\n      console.log(\r\n        `[ProcMap Piętro ${this.floorNumber}] Inicjalizacja zakończona. ${\r\n          this.rooms.length\r\n        } pokoi, Winda: ${\r\n          this.liftPosition\r\n            ? `OK w (${this.liftPosition.tileX}, ${this.liftPosition.tileY})`\r\n            : 'BŁĄD'\r\n        }, ${this.books.length} książek.`\r\n      );\r\n      // this.logMapGrid(); // Opcjonalnie: Zaloguj siatkę po wszystkim\r\n    } catch (error) {\r\n      console.error(\r\n        `[ProcMap Piętro ${this.floorNumber}] BŁĄD KRYTYCZNY podczas generowania mapy lub konfiguracji:`,\r\n        error\r\n      );\r\n      // Obsłuż błąd odpowiednio - może rzuć go dalej lub ustaw stan 'failed'\r\n      throw error; // Rzuć ponownie, aby zasygnalizować błąd wywołującemu (np. Game)\r\n    }\r\n  }\r\n\r\n  // --- Umieszczanie książek (Przeniesione tutaj, działa na wygenerowanej mapie) ---\r\n  placeBooksReliably(booksPerMap) {\r\n    this.books = []; // Wyczyść poprzednie książki\r\n    const potentialLocations = [];\r\n    const placedCoords = new Set();\r\n    console.log(`[ProcMap Piętro ${this.floorNumber}] Umieszczanie do ${booksPerMap} książek...`);\r\n\r\n    // Znajdź prawidłowe miejsca (korytarz lub podłoga pokoju, nie winda)\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        const tileValue = this.map[r]?.[c];\r\n        const isLiftTile =\r\n          this.liftPosition && r === this.liftPosition.tileY && c === this.liftPosition.tileX;\r\n        // Sprawdzamy CZY JEST to korytarz LUB podłoga pokoju ORAZ CZY NIE JEST to winda\r\n        if ((tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR || tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR) && !isLiftTile) {\r\n          potentialLocations.push({ r, c });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Umieść książki losowo z potencjalnych lokalizacji\r\n    let booksPlaced = 0;\r\n    while (booksPlaced < booksPerMap && potentialLocations.length > 0) {\r\n      const randomIndex = Math.floor(Math.random() * potentialLocations.length);\r\n      const { r, c } = potentialLocations.splice(randomIndex, 1)[0]; // Usuń wybraną lokalizację\r\n      const coordKey = `${c},${r}`;\r\n\r\n      // Podwójnie sprawdź kafelek na wszelki wypadek i upewnij się, że nie został już umieszczony (choć splice powinien temu zapobiec)\r\n      if (\r\n        (this.map[r]?.[c] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR || this.map[r]?.[c] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR) &&\r\n        !placedCoords.has(coordKey)\r\n      ) {\r\n        const bookWorldX = (c + 0.5) * this.tileSize;\r\n        const bookWorldY = (r + 0.5) * this.tileSize;\r\n        const bookId = `book_${this.floorNumber}_${booksPlaced + 1}`; // Unikalne ID na piętro/książkę\r\n        this.books.push(new _Book_js__WEBPACK_IMPORTED_MODULE_0__.Book(bookWorldX, bookWorldY, bookId, this.tileSize));\r\n        placedCoords.add(coordKey);\r\n        booksPlaced++;\r\n      }\r\n    }\r\n\r\n    if (booksPlaced < booksPerMap) {\r\n      console.warn(`[ProcMap Książki] Umieszczono tylko ${booksPlaced}/${booksPerMap} książek.`);\r\n    } else {\r\n      console.log(`[ProcMap Książki] Umieszczono ${booksPlaced} książek.`);\r\n    }\r\n  }\r\n\r\n  // --- Metody interakcji ---\r\n\r\n  isWalkable(worldX, worldY) {\r\n    if (!this.map) return false; // Mapa nie wygenerowana\r\n    const tileX = Math.floor(worldX / this.tileSize);\r\n    const tileY = Math.floor(worldY / this.tileSize);\r\n\r\n    if (tileX < 0 || tileX >= this.cols || tileY < 0 || tileY >= this.rows) {\r\n      return false; // Poza granicami mapy\r\n    }\r\n\r\n    const tileValue = this.map[tileY]?.[tileX];\r\n    // Sprawdź typy przechodnich kafelków - WINDA JEST PRZECHODNIA (dla kolizji, niekoniecznie do stania)\r\n    return tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR || tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR || tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_LIFT;\r\n  }\r\n\r\n  findRandomInitialSpawnPosition() {\r\n    if (!this.map) return undefined;\r\n    const suitableTiles = [];\r\n    // Preferuj kafelki nie sąsiadujące bezpośrednio ze ścianami dla mniej ciasnego startu\r\n    for (let r = 1; r < this.rows - 1; r++) {\r\n      for (let c = 1; c < this.cols - 1; c++) {\r\n        const tileValue = this.map[r]?.[c];\r\n        const isLift =\r\n          this.liftPosition && r === this.liftPosition.tileY && c === this.liftPosition.tileX;\r\n        // Szukamy korytarza lub podłogi pokoju, ALE NIE WINDY\r\n        if ((tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR || tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR) && !isLift) {\r\n          // Sprawdź, czy jest otoczony przez nie-ściany (więcej otwartej przestrzeni)\r\n          if (\r\n            this.map[r - 1]?.[c] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_WALL &&\r\n            this.map[r + 1]?.[c] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_WALL &&\r\n            this.map[r]?.[c - 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_WALL &&\r\n            this.map[r]?.[c + 1] !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_WALL\r\n          ) {\r\n            suitableTiles.push({ r, c });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Wycofanie: Jeśli nie znaleziono otwartych przestrzeni, użyj dowolnego prawidłowego kafelka podłogi/korytarza (nadal nie windy)\r\n    if (suitableTiles.length === 0) {\r\n      console.warn(\r\n        \"[MapGen Spawn] Nie znaleziono 'otwartych' punktów startowych, używam dowolnego przechodniego kafelka nie będącego windą.\"\r\n      );\r\n      for (let r = 0; r < this.rows; r++) {\r\n        for (let c = 0; c < this.cols; c++) {\r\n          const tileValue = this.map[r]?.[c];\r\n          const isLift =\r\n            this.liftPosition && r === this.liftPosition.tileY && c === this.liftPosition.tileX;\r\n          if ((tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR || tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR) && !isLift) {\r\n            suitableTiles.push({ r, c });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (suitableTiles.length === 0) {\r\n      console.error(\r\n        `[MapGen Spawn] KRYTYCZNY: Nie znaleziono odpowiednich kafelków startowych (podłoga/korytarz niebędący windą)!`\r\n      );\r\n      return undefined; // Zasygnalizuj błąd\r\n    }\r\n\r\n    const { r, c } = suitableTiles[Math.floor(Math.random() * suitableTiles.length)];\r\n    const worldX = (c + 0.5) * this.tileSize;\r\n    const worldY = (r + 0.5) * this.tileSize;\r\n    console.log(`[MapGen Spawn] Znaleziono początkowy spawn na kratce(${c}, ${r})`);\r\n    return { x: worldX, y: worldY };\r\n  }\r\n\r\n  /**\r\n   * Znajduje najbliższą BEZPIECZNĄ przechodnią kratkę (KORYTARZ lub PODŁOGA_POKOJU)\r\n   * do docelowej pozycji w świecie.\r\n   * Używa wyszukiwania w rozszerzającym się promieniu, a jako fallback BFS.\r\n   * @param {number} targetWorldX Docelowa współrzędna X w świecie.\r\n   * @param {number} targetWorldY Docelowa współrzędna Y w świecie.\r\n   * @param {number} [maxRadius=8] Maksymalny promień początkowego wyszukiwania.\r\n   * @param {boolean} [excludeLift=false] Jeśli true, WYNIK nie może być kratką windy.\r\n   * @returns {{x: number, y: number} | null} Współrzędne środka znalezionej kratki w świecie lub null.\r\n   */\r\n  findNearestWalkableTile(targetWorldX, targetWorldY, maxRadius = 8, excludeLift = false) {\r\n    if (!this.map) return null;\r\n\r\n    const targetTileX = Math.floor(targetWorldX / this.tileSize);\r\n    const targetTileY = Math.floor(targetWorldY / this.tileSize);\r\n\r\n    console.log(\r\n      `[MapUtil] Szukanie najbliższej BEZPIECZNEJ kratki (excludeLift=${excludeLift}) blisko świata(${targetWorldX.toFixed(\r\n        1\r\n      )}, ${targetWorldY.toFixed(1)}) -> kratka(${targetTileX}, ${targetTileY})`\r\n    );\r\n\r\n    const targetSafeTiles = [_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR]; // Cel: Korytarz lub podłoga pokoju\r\n    if (!excludeLift) {\r\n      // Jeśli nie wykluczamy windy, to ona też jest potencjalnym celem\r\n      // targetSafeTiles.push(TILE_LIFT); // --> Zdecydowaliśmy, że ZAWSZE szukamy korytarza/pokoju\r\n    }\r\n\r\n    // 1. Sprawdzenie SAMEJ kratki docelowej (jeśli jest bezpieczna)\r\n    const startTileValue = this.map[targetTileY]?.[targetTileX];\r\n    if (targetSafeTiles.includes(startTileValue)) {\r\n      // Sprawdź tylko, czy to nie jest winda, jeśli excludeLift=true\r\n      if (!excludeLift || startTileValue !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_LIFT) {\r\n        console.log(\r\n          `  [MapUtil] Kratka docelowa (${targetTileX}, ${targetTileY}) jest już bezpieczna.`\r\n        );\r\n        return { x: (targetTileX + 0.5) * this.tileSize, y: (targetTileY + 0.5) * this.tileSize };\r\n      }\r\n    }\r\n\r\n    // 2. Wyszukiwanie Promieniowe (szukamy KORYTARZA lub PODŁOGI POKOJU)\r\n    for (let radius = 1; radius <= maxRadius; radius++) {\r\n      for (let dy = -radius; dy <= radius; dy++) {\r\n        for (let dx = -radius; dx <= radius; dx++) {\r\n          // Sprawdzamy tylko granicę obecnego promienia\r\n          if (Math.abs(dx) < radius && Math.abs(dy) < radius) continue;\r\n\r\n          const checkX = targetTileX + dx;\r\n          const checkY = targetTileY + dy;\r\n\r\n          // Upewnij się, że w granicach\r\n          if (checkX < 0 || checkX >= this.cols || checkY < 0 || checkY >= this.rows) continue;\r\n\r\n          const tileValue = this.map[checkY]?.[checkX];\r\n          // Znaleziono bezpieczne miejsce (korytarz lub podłoga pokoju)?\r\n          if (tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR || tileValue === _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR) {\r\n            console.log(\r\n              `  [MapUtil] Znaleziono bezpieczną kratkę przez wyszukiwanie promieniowe na kratce(${checkX}, ${checkY})`\r\n            );\r\n            return { x: (checkX + 0.5) * this.tileSize, y: (checkY + 0.5) * this.tileSize };\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3. Wyszukiwanie BFS (Fallback) - Szukaj od celu na zewnątrz\r\n    console.warn(\r\n      `[MapUtil] Wyszukiwanie promieniowe nie powiodło się (maxPromień ${maxRadius}). Rozpoczynam BFS od kratki(${targetTileX}, ${targetTileY})...`\r\n    );\r\n    const queue = [[targetTileX, targetTileY]];\r\n    const visited = new Set([`${targetTileX},${targetTileY}`]);\r\n    const directions = [\r\n      [0, -1],\r\n      [0, 1],\r\n      [-1, 0],\r\n      [1, 0],\r\n    ];\r\n    // Przechodnie kratki *dla ścieżki wyszukiwania BFS* (można przejść PRZEZ windę, ale WINDA nie jest CELEM, jeśli excludeLift=true)\r\n    const bfsWalkablePath = [_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR, _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_LIFT];\r\n\r\n    while (queue.length > 0) {\r\n      const [currX, currY] = queue.shift();\r\n\r\n      for (const [dx, dy] of directions) {\r\n        const nextX = currX + dx;\r\n        const nextY = currY + dy;\r\n        const key = `${nextX},${nextY}`;\r\n\r\n        if (\r\n          nextX >= 0 &&\r\n          nextX < this.cols &&\r\n          nextY >= 0 &&\r\n          nextY < this.rows &&\r\n          !visited.has(key)\r\n        ) {\r\n          const tileValue = this.map[nextY]?.[nextX];\r\n          visited.add(key); // Oznacz jako odwiedzone niezależnie od typu dla efektywności BFS\r\n\r\n          // Znaleziono docelową bezpieczną kratkę? (Korytarz lub Podłoga Pokoju)\r\n          if (targetSafeTiles.includes(tileValue)) {\r\n            // Dodatkowe sprawdzenie, jeśli wykluczamy windę\r\n            if (!excludeLift || tileValue !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_LIFT) {\r\n              console.log(\r\n                `  [MapUtil] Znaleziono bezpieczną kratkę przez BFS na (${nextX}, ${nextY})`\r\n              );\r\n              return { x: (nextX + 0.5) * this.tileSize, y: (nextY + 0.5) * this.tileSize };\r\n            }\r\n          }\r\n\r\n          // Czy możemy kontynuować wyszukiwanie Z tego sąsiada? (Korytarz, Podłoga Pokoju LUB Winda)\r\n          if (bfsWalkablePath.includes(tileValue)) {\r\n            queue.push([nextX, nextY]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    console.error(\r\n      `[MapUtil] KRYTYCZNA PORAŻKA: BFS nie mógł znaleźć ŻADNEJ bezpiecznej przechodniej kratki (Korytarz/Podłoga Pokoju, excludeLift=${excludeLift}) zaczynając od kratki(${targetTileX}, ${targetTileY})!`\r\n    );\r\n    return null; // Zasygnalizuj całkowitą porażkę\r\n  }\r\n\r\n  findNearbyUnansweredBook(worldX, worldY, radius = this.tileSize * 0.8) {\r\n    if (!this.books) return null;\r\n    let closestBook = null;\r\n    let minDistanceSq = radius * radius;\r\n\r\n    for (const book of this.books) {\r\n      const isCollected = book.isCollected || book.collected; // Sprawdź obie flagi\r\n      if (!isCollected) {\r\n        const dx = book.x - worldX;\r\n        const dy = book.y - worldY;\r\n        const distanceSq = dx * dx + dy * dy;\r\n        if (distanceSq < minDistanceSq) {\r\n          minDistanceSq = distanceSq;\r\n          closestBook = book;\r\n        }\r\n      }\r\n    }\r\n    return closestBook;\r\n  }\r\n\r\n  markBookAsCollected(bookToCollect) {\r\n    if (!bookToCollect || !this.books) return false;\r\n    const book = this.books.find((b) => b === bookToCollect || b.id === bookToCollect.id);\r\n    if (book && !(book.isCollected || book.collected)) {\r\n      book.isCollected = true;\r\n      book.collected = true; // Ustaw obie dla bezpieczeństwa\r\n      console.log(`[Map] Oznaczono książkę ${book.id} jako zebraną.`);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  findNearbyLift(worldX, worldY, radius = this.tileSize * _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.LIFT_INTERACTION_RADIUS_MULTIPLIER) {\r\n    if (!this.liftPosition) return null;\r\n    // Sprawdź odległość od środka postaci do środka kafelka windy\r\n    const dx = worldX - this.liftPosition.x;\r\n    const dy = worldY - this.liftPosition.y;\r\n    const distanceSq = dx * dx + dy * dy;\r\n    return distanceSq < radius * radius ? this.liftPosition : null;\r\n  }\r\n\r\n  getLiftPosition() {\r\n    // Upewnij się, że zwracasz kopię, jeśli liftPosition jest modyfikowalne, chociaż tutaj wydaje się ok\r\n    return this.liftPosition;\r\n  }\r\n\r\n  // --- Rysowanie ---\r\n  draw(ctx, bookImage = null) {\r\n    if (!this.map || !this.renderer) return; // Nie rysuj, jeśli mapa nie została wygenerowana\r\n\r\n    // Przygotuj payload danych dla renderera\r\n    const mapData = {\r\n      map: this.map,\r\n      rooms: this.rooms,\r\n      books: this.books,\r\n      liftPosition: this.liftPosition,\r\n      offsetX: this.offsetX, // Przekaż potencjalnie niecałkowity offset\r\n      offsetY: this.offsetY,\r\n      cols: this.cols,\r\n      rows: this.rows,\r\n      tileSize: this.tileSize,\r\n    };\r\n\r\n    // Deleguj rysowanie do renderera\r\n    this.renderer.draw(ctx, mapData, bookImage);\r\n  }\r\n\r\n  // --- Debugowanie ---\r\n  logMapGrid() {\r\n    if (!this.map) {\r\n      console.log('Siatka mapy niedostępna.');\r\n      return;\r\n    }\r\n    console.log(`--- Siatka Mapy Piętro ${this.floorNumber} (${this.cols}x${this.rows}) ---`);\r\n    let header = '   ';\r\n    for (let c = 0; c < this.cols; c++) header += c % 10 === 0 ? Math.floor(c / 10) : ' ';\r\n    console.log(header);\r\n    header = '   ';\r\n    for (let c = 0; c < this.cols; c++) header += c % 10;\r\n    console.log(header);\r\n    for (let y = 0; y < this.rows; y++) {\r\n      const rowNum = y.toString().padStart(2, ' ');\r\n      const rowString = this.map[y]\r\n        .map((tile) => {\r\n          switch (tile) {\r\n            case _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_WALL:\r\n              return '#'; // Ściana\r\n            case _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_CORRIDOR:\r\n              return '.'; // Korytarz\r\n            case _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_ROOM_FLOOR:\r\n              return ' '; // Podłoga pokoju\r\n            case _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__.TILE_LIFT:\r\n              return 'L'; // Winda\r\n            default:\r\n              return '?'; // Nieznany\r\n          }\r\n        })\r\n        .join('');\r\n      console.log(`${rowNum} ${rowString}`);\r\n    }\r\n    // Zaloguj pozycję windy dla weryfikacji\r\n    if (this.liftPosition) {\r\n      console.log(`Winda na kratce: (${this.liftPosition.tileX}, ${this.liftPosition.tileY})`);\r\n    } else {\r\n      console.log('Pozycja windy nie ustawiona.');\r\n    }\r\n    console.log(`--- Koniec Siatki Mapy Piętro ${this.floorNumber} ---`);\r\n  }\r\n} // Koniec klasy ProceduralMap\r\n\n\n//# sourceURL=webpack://projectjs/./js/map/ProceduralMap.js?");

/***/ }),

/***/ "./js/utils/constants.js":
/*!*******************************!*\
  !*** ./js/utils/constants.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GYM_CHANCE_ON_FIRST_FLOOR: () => (/* binding */ GYM_CHANCE_ON_FIRST_FLOOR),\n/* harmony export */   GameState: () => (/* binding */ GameState),\n/* harmony export */   LIFT_COOLDOWN_MS: () => (/* binding */ LIFT_COOLDOWN_MS),\n/* harmony export */   LIFT_INTERACTION_RADIUS_MULTIPLIER: () => (/* binding */ LIFT_INTERACTION_RADIUS_MULTIPLIER),\n/* harmony export */   TARGET_BOOKS_TO_WIN: () => (/* binding */ TARGET_BOOKS_TO_WIN),\n/* harmony export */   TILE_CORRIDOR: () => (/* binding */ TILE_CORRIDOR),\n/* harmony export */   TILE_LIFT: () => (/* binding */ TILE_LIFT),\n/* harmony export */   TILE_ROOM_FLOOR: () => (/* binding */ TILE_ROOM_FLOOR),\n/* harmony export */   TILE_WALL: () => (/* binding */ TILE_WALL),\n/* harmony export */   questions: () => (/* binding */ questions)\n/* harmony export */ });\n// src/utils/constants.js\r\n\r\n// Definicje typów kafelków mapy\r\nconst TILE_WALL = 0; // Ściana\r\nconst TILE_CORRIDOR = 1; // Korytarz\r\nconst TILE_ROOM_FLOOR = 2; // Podłoga pokoju\r\nconst TILE_LIFT = 3; // Winda\r\n// Można dodać więcej typów, np. TILE_DOOR, TILE_WINDOW itp.\r\n\r\n// Stany gry\r\nconst GameState = {\r\n  LOADING: 'LOADING', // Ładowanie zasobów, generowanie poziomu\r\n  MENU: 'MENU', // Menu główne (wybór postaci)\r\n  PLAYING: 'PLAYING', // Główna rozgrywka\r\n  ASKING_QUESTION: 'ASKING_QUESTION', // Wyświetlanie pytania\r\n  SELECTING_FLOOR: 'SELECTING_FLOOR', // Wyświetlanie UI wyboru piętra\r\n  TRANSITIONING: 'TRANSITIONING', // Animacja/oczekiwanie na przejście windy\r\n  GAME_OVER: 'GAME_OVER', // Koniec gry (wygrana lub przegrana)\r\n};\r\n\r\n// Parametry rozgrywki\r\nconst TARGET_BOOKS_TO_WIN = 15; // Liczba książek do zebrania, aby wygrać (globalnie)\r\nconst LIFT_COOLDOWN_MS = 2000; // Czas odnowienia windy w milisekundach (2 sekundy)\r\nconst LIFT_INTERACTION_RADIUS_MULTIPLIER = 0.7; // Mnożnik promienia interakcji z windą (względem tileSize)\r\n\r\n// Szansa na pojawienie się siłowni na pierwszym piętrze (0.0 do 1.0)\r\nconst GYM_CHANCE_ON_FIRST_FLOOR = 0.6; // 60% szansy\r\n\r\n// Pytania i odpowiedzi\r\nconst questions = [\r\n  {\r\n    question:\r\n      'Który język programowania jest znany ze swojej wszechstronności i używany zarówno w backendzie (Node.js), jak i frontendzie?',\r\n    options: ['Python', 'Java', 'JavaScript', 'C#'],\r\n    correctAnswer: 2, // Indeks poprawnej odpowiedzi (JavaScript)\r\n  },\r\n  {\r\n    question: 'Co oznacza skrót HTML?',\r\n    options: [\r\n      'HyperText Markup Language',\r\n      'High Transfer Machine Language',\r\n      'Hyperlink and Text Management Language',\r\n      'Home Tool Markup Language',\r\n    ],\r\n    correctAnswer: 0,\r\n  },\r\n  {\r\n    question: 'Która struktura danych działa na zasadzie LIFO (Last-In, First-Out)?',\r\n    options: ['Kolejka (Queue)', 'Stos (Stack)', 'Lista (List)', 'Drzewo (Tree)'],\r\n    correctAnswer: 1,\r\n  },\r\n  {\r\n    question: 'Jak nazywa się proces znajdowania i naprawiania błędów w kodzie?',\r\n    options: ['Kompilacja', 'Testowanie', 'Debugowanie', 'Refaktoryzacja'],\r\n    correctAnswer: 2,\r\n  },\r\n  {\r\n    question:\r\n      \"Który paradygmat programowania opiera się na koncepcji 'obiektów', które mogą zawierać dane i kod?\",\r\n    options: [\r\n      'Programowanie funkcyjne',\r\n      'Programowanie proceduralne',\r\n      'Programowanie obiektowe',\r\n      'Programowanie logiczne',\r\n    ],\r\n    correctAnswer: 2,\r\n  },\r\n  {\r\n    question: 'Co oznacza CSS?',\r\n    options: [\r\n      'Cascading Style Sheets',\r\n      'Computer Style Syntax',\r\n      'Creative Styling System',\r\n      'Colorful Style Scripts',\r\n    ],\r\n    correctAnswer: 0,\r\n  },\r\n  {\r\n    question: 'Który operator w JavaScript służy do ścisłego porównania (wartość i typ)?',\r\n    options: ['==', '=', '===', '!='],\r\n    correctAnswer: 2,\r\n  },\r\n  {\r\n    question: 'Jak nazywa się popularny system kontroli wersji używany przez programistów?',\r\n    options: ['Subversion (SVN)', 'Git', 'Mercurial', 'CVS'],\r\n    correctAnswer: 1,\r\n  },\r\n  {\r\n    question:\r\n      'Który typ pętli w większości języków programowania jest najbardziej odpowiedni do iteracji po elementach tablicy, gdy nie znamy ich liczby?',\r\n    options: ['for', 'while', 'do...while', 'foreach (lub for...of)'],\r\n    correctAnswer: 3,\r\n  },\r\n  {\r\n    question: 'Co to jest API?',\r\n    options: [\r\n      'Advanced Programming Interface',\r\n      'Application Programming Interface',\r\n      'Automated Program Interaction',\r\n      'Algorithmic Processing Input',\r\n    ],\r\n    correctAnswer: 1,\r\n  },\r\n  // Dodaj więcej pytań tutaj\r\n];\r\n\n\n//# sourceURL=webpack://projectjs/./js/utils/constants.js?");

/***/ }),

/***/ "./js/utils/map.js":
/*!*************************!*\
  !*** ./js/utils/map.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjustColorBrightness: () => (/* binding */ adjustColorBrightness),\n/* harmony export */   performBFS: () => (/* binding */ performBFS),\n/* harmony export */   randomCorridorGray: () => (/* binding */ randomCorridorGray),\n/* harmony export */   randomGray: () => (/* binding */ randomGray),\n/* harmony export */   randomInt: () => (/* binding */ randomInt),\n/* harmony export */   simpleHash: () => (/* binding */ simpleHash)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./js/utils/constants.js\");\n// src/utils/map.js\r\n // Potrzebne do BFS\r\n\r\n/**\r\n * Generuje losową liczbę całkowitą z przedziału [min, max] (włącznie).\r\n * @param {number} min Dolna granica.\r\n * @param {number} max Górna granica.\r\n * @returns {number} Losowa liczba całkowita.\r\n */\r\nfunction randomInt(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\n/**\r\n * Prosta (niekryptograficzna) funkcja hashująca.\r\n * Używana do uzyskania pseudolosowej, ale deterministycznej wartości z liczby (koordynatów).\r\n * @param {number} seed Ziarno (np. skombinowane koordynaty).\r\n * @returns {number} Bezznakowa 32-bitowa liczba całkowita.\r\n */\r\nfunction simpleHash(seed) {\r\n  let h = seed ^ 0xdeadbeef; // XOR z wartością początkową\r\n  h = Math.imul(h ^ (h >>> 16), 2246822507);\r\n  h = Math.imul(h ^ (h >>> 13), 3266489909);\r\n  return (h ^= h >>> 16) >>> 0; // Konwersja do liczby bez znaku 32-bitowej\r\n}\r\n\r\n// --- Funkcje kolorów ---\r\n\r\n/**\r\n * Generuje losowy odcień szarości w zadanym zakresie jasności (0-255).\r\n * @param {number} minBrightness Minimalna jasność.\r\n * @param {number} maxBrightness Maksymalna jasność.\r\n * @returns {string} Kolor w formacie rgb().\r\n */\r\nfunction randomGray(minBrightness, maxBrightness) {\r\n  const brightness = randomInt(minBrightness, maxBrightness);\r\n  return `rgb(${brightness},${brightness},${brightness})`;\r\n}\r\n\r\n/**\r\n * Generuje losowy odcień szarości dla korytarzy.\r\n * @param {number} minBrightness Minimalna jasność.\r\n * @param {number} maxBrightness Maksymalna jasność.\r\n * @returns {string} Kolor w formacie rgb().\r\n */\r\nfunction randomCorridorGray(minBrightness, maxBrightness) {\r\n  // Można użyć tej samej logiki co randomGray lub uczynić je nieco cieplejszymi/chłodniejszymi\r\n  const brightness = randomInt(minBrightness, maxBrightness);\r\n  return `rgb(${brightness},${brightness},${brightness})`;\r\n}\r\n\r\n/**\r\n * Dostosowuje jasność koloru HEX (np. '#RRGGBB').\r\n * @param {string} hexColor Kolor w formacie HEX.\r\n * @param {number} factor Współczynnik jasności (1.0 = bez zmian, <1 ciemniej, >1 jaśniej).\r\n * @returns {string} Nowy kolor w formacie HEX.\r\n */\r\nfunction adjustColorBrightness(hexColor, factor) {\r\n  if (!hexColor || typeof hexColor !== 'string' || hexColor.length < 7) return hexColor; // Zwróć, jeśli kolor jest nieprawidłowy\r\n\r\n  let r = parseInt(hexColor.slice(1, 3), 16);\r\n  let g = parseInt(hexColor.slice(3, 5), 16);\r\n  let b = parseInt(hexColor.slice(5, 7), 16);\r\n\r\n  r = Math.min(255, Math.max(0, Math.round(r * factor)));\r\n  g = Math.min(255, Math.max(0, Math.round(g * factor)));\r\n  b = Math.min(255, Math.max(0, Math.round(b * factor)));\r\n\r\n  const rHex = r.toString(16).padStart(2, '0');\r\n  const gHex = g.toString(16).padStart(2, '0');\r\n  const bHex = b.toString(16).padStart(2, '0');\r\n\r\n  return `#${rHex}${gHex}${bHex}`;\r\n}\r\n\r\n/**\r\n * Wykonuje algorytm przeszukiwania wszerz (BFS) na siatce mapy.\r\n * Może być używany do znajdowania ścieżki lub sprawdzania osiągalności.\r\n * @param {number[][]} mapGrid Siatka mapy (2D array z wartościami kafelków).\r\n * @param {number} startX Początkowa współrzędna X kafelka.\r\n * @param {number} startY Początkowa współrzędna Y kafelka.\r\n * @param {number} cols Liczba kolumn w mapGrid.\r\n * @param {number} rows Liczba rzędów w mapGrid.\r\n * @param {number[]} walkableTileValues Tablica wartości kafelków uważanych za przechodnie dla tego BFS.\r\n * @returns {{reachable: boolean}} Obiekt wskazujący, czy BFS osiągnął określony cel (w tym przypadku, czy z punktu startowego można dojść do korytarza/pokoju).\r\n */\r\nfunction performBFS(mapGrid, startX, startY, cols, rows, walkableTileValues) {\r\n  const queue = [[startX, startY]];\r\n  const visited = new Set([`${startX},${startY}`]);\r\n  const directions = [\r\n    [0, -1], // Góra\r\n    [0, 1], // Dół\r\n    [-1, 0], // Lewo\r\n    [1, 0], // Prawo\r\n  ];\r\n  let reachable = false; // Flaga, czy BFS dotarł do kafelków korytarza/pokoju (jeśli szukano od windy)\r\n\r\n  // Sprawdzenie punktu startowego (jeśli szukamy osiągalności z windy)\r\n  const startTileValue = mapGrid[startY]?.[startX];\r\n  // Czy punkt startowy (np. winda) jest już na bezpiecznym terenie (dla celu sprawdzenia osiągalności)?\r\n  // W tym konkretnym użyciu (sprawdzenie windy) interesuje nas, czy z windy można dotrzeć do KORYTARZA/POKOJU.\r\n  // Samo stanie na windzie nie oznacza osiągalności bezpiecznej strefy.\r\n  // Sprawdzimy sąsiadów windy.\r\n\r\n  while (queue.length > 0) {\r\n    const [currX, currY] = queue.shift();\r\n\r\n    for (const [dx, dy] of directions) {\r\n      const nextX = currX + dx;\r\n      const nextY = currY + dy;\r\n      const key = `${nextX},${nextY}`;\r\n\r\n      // Sprawdzenie granic i czy już odwiedzone\r\n      if (nextX >= 0 && nextX < cols && nextY >= 0 && nextY < rows && !visited.has(key)) {\r\n        const tileValue = mapGrid[nextY]?.[nextX];\r\n        visited.add(key); // Odwiedzamy niezależnie od typu\r\n\r\n        // Czy ten kafelek jest przechodni DLA TEGO BFS?\r\n        if (walkableTileValues.includes(tileValue)) {\r\n          queue.push([nextX, nextY]);\r\n\r\n          // Czy ten kafelek jest KORYTARZEM lub PODŁOGĄ POKOJU?\r\n          // Jeśli tak, to znaleźliśmy bezpieczną strefę osiągalną z punktu startowego.\r\n          if (tileValue === _constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_CORRIDOR || tileValue === _constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ROOM_FLOOR) {\r\n            reachable = true;\r\n            // Można by tu zakończyć pętlę, jeśli interesuje nas tylko CZY jest osiągalne\r\n            // return { reachable: true };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Zwróć wynik BFS - w tym przypadku, flagę osiągalności bezpiecznej strefy\r\n  return { reachable };\r\n}\r\n\r\n// ... (inne narzędzia mapy, jeśli istnieją)\r\n\n\n//# sourceURL=webpack://projectjs/./js/utils/map.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/main.js");
/******/ 	
/******/ })()
;